<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 丙午马年 · 烈火战马</title>
    <link href="https://fonts.googleapis.com/css2?family=Zcool+KuaiLe&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; background: #0a0000; overflow: hidden; font-family: 'Orbitron', sans-serif; user-select: none; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        
        /* UI 层 */
        #ui {
            position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px;
        }

        /* 启动层 */
        #intro {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 0, 0, 0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
        }

        h1 {
            font-family: 'Zcool KuaiLe', cursive; font-size: 7rem; margin: 0;
            background: linear-gradient(to top, #ff0000, #ff4500, #ffcc00);
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 50px rgba(255, 69, 0, 0.6);
            animation: burn 0.1s infinite alternate;
        }

        .btn {
            margin-top: 50px; padding: 15px 50px; font-size: 1.5rem;
            color: #ffcc00; background: transparent; border: 2px solid #ff4500;
            font-family: 'Orbitron', sans-serif; cursor: pointer;
            box-shadow: 0 0 20px #ff4500; transition: 0.3s;
            pointer-events: auto;
        }
        .btn:hover { background: #ff4500; color: #000; box-shadow: 0 0 60px #ff4500; }

        /* 状态显示 */
        .hud { color: #ff4500; font-size: 12px; letter-spacing: 2px; text-shadow: 0 0 5px #ff0000; }
        
        /* 祝福语动画 */
        .blessing-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Zcool KuaiLe', cursive; font-size: 10rem;
            color: rgba(255, 255, 255, 0.1); pointer-events: none;
            white-space: nowrap; mix-blend-mode: overlay;
        }

        @keyframes burn { 
            0% { text-shadow: 0 0 40px rgba(255, 69, 0, 0.6); transform: skewX(0deg); } 
            100% { text-shadow: 0 0 60px rgba(255, 200, 0, 0.8); transform: skewX(-2deg); } 
        }

        video { display: none; }
    </style>
</head>
<body>

    <div id="intro">
        <div style="color: #ff8800; letter-spacing: 10px; margin-bottom: 20px;">2026 BING WU YEAR</div>
        <h1>烈火战马</h1>
        <button class="btn" onclick="startEngine()">RIDE THE FIRE</button>
        <p style="color: #666; margin-top: 20px; font-size: 12px;">建议佩戴耳机 · 体验音画同步</p>
    </div>

    <div id="ui">
        <div class="hud">
            <div>SPEED: <span id="speed-val">0</span> KM/H</div>
            <div>STATUS: <span id="status-val">IDLE</span></div>
        </div>
        <div class="blessing-text" id="bg-text">丙午</div>
    </div>

    <canvas id="canvas"></canvas>
    <video id="input_video" playsinline></video>

    <script>
        /* =================================================================
           AUDIO: 战马音效合成 (Horse Sound Synthesis)
           ================================================================= */
        const AudioSys = {
            ctx: null,
            gallopOsc: null,
            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.setupGallop();
            },
            
            // 模拟马蹄声 (低频脉冲)
            setupGallop() {
                // 这是一个基础的节奏生成器，但在交互中我们会实时触发
            },

            playGallopStep(intensity) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // 模拟蹄声：低频噪音/方波混合
                osc.type = 'square';
                osc.frequency.setValueAtTime(80, t);
                osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3 * intensity, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

                // 低通滤波让声音更像撞击地面
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(t);
                osc.stop(t + 0.2);
            },

            // 模拟马嘶鸣 (高频滑音)
            playNeigh() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(1500, t);
                // 频率抖动 + 下滑
                osc.frequency.linearRampToValueAtTime(2000, t + 0.2);
                osc.frequency.linearRampToValueAtTime(800, t + 1.0);

                // 颤音 (LFO)
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 10;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 500;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(t);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.2, t + 0.1);
                gain.gain.linearRampToValueAtTime(0, t + 1.2);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 1.5);
            }
        };

        /* =================================================================
           VISUALS: 烈火粒子系统 (Fire Particle System)
           ================================================================= */
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height;

        // 粒子池 (Typed Array for Performance)
        const P_COUNT = 5000;
        const P = {
            x: new Float32Array(P_COUNT),
            y: new Float32Array(P_COUNT),
            vx: new Float32Array(P_COUNT),
            vy: new Float32Array(P_COUNT),
            life: new Float32Array(P_COUNT),
            color: new Float32Array(P_COUNT) // 0-1 hue lerp
        };

        // 目标点（手）
        const mouse = { x: 0, y: 0, active: false, vx: 0, vy: 0 };
        // 2026 祝福词
        const words = ["一马当先", "万马奔腾", "马到成功", "龙马精神", "2026"];
        let wordTargets = [];
        let currentWordIdx = 0;
        let mode = 'RUN'; // RUN (自由奔跑), FORM (聚合文字)

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // 重置粒子
            for(let i=0; i<P_COUNT; i++) {
                P.x[i] = Math.random() * width;
                P.y[i] = Math.random() * height;
                P.life[i] = Math.random();
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // 文字点阵生成器
        function generateTextPoints(text) {
            const tmpC = document.createElement('canvas');
            tmpC.width = width; tmpC.height = height;
            const tCtx = tmpC.getContext('2d');
            tCtx.fillStyle = '#000'; tCtx.fillRect(0,0,width,height);
            tCtx.fillStyle = '#fff';
            tCtx.font = 'bold 300px "Zcool KuaiLe"';
            tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle';
            tCtx.fillText(text, width/2, height/2);
            
            const data = tCtx.getImageData(0,0,width,height).data;
            const points = [];
            const step = 5; 
            for(let y=0; y<height; y+=step) {
                for(let x=0; x<width; x+=step) {
                    if(data[(y*width+x)*4] > 128) points.push({x,y});
                }
            }
            return points;
        }

        /* =================================================================
           PHYSICS LOOP
           ================================================================= */
        let frame = 0;
        
        function update() {
            // 背景淡出 (产生运动拖尾) - 红色调
            ctx.fillStyle = 'rgba(10, 0, 0, 0.2)'; 
            ctx.fillRect(0, 0, width, height);

            // 绘制模式
            ctx.globalCompositeOperation = 'lighter'; // 叠加发光

            const centerX = width/2;
            const centerY = height/2;
            const handX = mouse.active ? mouse.x : centerX + Math.sin(frame*0.05)*300;
            const handY = mouse.active ? mouse.y : centerY + Math.cos(frame*0.03)*100;

            // 计算速度感 (Visual Speed)
            const speed = Math.sqrt(mouse.vx*mouse.vx + mouse.vy*mouse.vy);
            document.getElementById('speed-val').innerText = Math.round(speed * 10);
            
            // 音效触发：根据速度触发蹄声
            if(speed > 10 && frame % 10 === 0) AudioSys.playGallopStep(Math.min(speed/50, 1));

            for(let i=0; i<P_COUNT; i++) {
                let p_x = P.x[i];
                let p_y = P.y[i];
                let p_vx = P.vx[i];
                let p_vy = P.vy[i];

                if (mode === 'FORM' && wordTargets.length > 0) {
                    // === 聚合模式 (文字) ===
                    const target = wordTargets[i % wordTargets.length];
                    // 弹簧力
                    const dx = target.x - p_x;
                    const dy = target.y - p_y;
                    p_vx += dx * 0.05;
                    p_vy += dy * 0.05;
                    // 阻尼
                    p_vx *= 0.8;
                    p_vy *= 0.8;
                    // 颜色：金黄
                    ctx.fillStyle = `rgba(255, 215, 0, 0.8)`;

                } else {
                    // === 奔跑模式 (Fire Flow) ===
                    
                    // 1. 全局向左奔跑 (模拟风)
                    p_vx -= 0.5; 

                    // 2. 手指吸引力 (Fire Source)
                    const dx = handX - p_x;
                    const dy = handY - p_y;
                    const distSq = dx*dx + dy*dy;
                    
                    if (distSq < 50000) { // 在手周围
                        const force = (50000 - distSq) / 50000;
                        p_vx += dx * force * 0.1;
                        p_vy += dy * force * 0.1;
                        
                        // 扰动
                        p_vx += (Math.random()-0.5) * 5;
                        p_vy += (Math.random()-0.5) * 5;
                        
                        // 颜色：核心白热，边缘红
                        const heat = Math.random();
                        ctx.fillStyle = `rgba(255, ${Math.floor(heat*255)}, 0, ${P.life[i]})`;
                    } else {
                        // 自由粒子：红橙色
                        p_vx *= 0.95;
                        p_vy *= 0.95;
                        ctx.fillStyle = `rgba(255, 69, 0, ${P.life[i]*0.5})`;
                    }
                    
                    // 噪点流动
                    const angle = Math.cos(p_x*0.01) + Math.sin(p_y*0.01) * 2;
                    p_vx += Math.cos(angle) * 0.2;
                    p_vy += Math.sin(angle) * 0.2;
                }

                // 更新位置
                p_x += p_vx;
                p_y += p_vy;
                
                // 边界循环
                if(p_x < 0) p_x = width;
                if(p_x > width) p_x = 0;
                if(p_y < 0) p_y = height;
                if(p_y > height) p_y = 0;

                // 存回数组
                P.x[i] = p_x;
                P.y[i] = p_y;
                P.vx[i] = p_vx;
                P.vy[i] = p_vy;

                // 绘制 (高性能 Rect)
                ctx.fillRect(p_x, p_y, 2, 2);
            }
            
            ctx.globalCompositeOperation = 'source-over';
            frame++;
            requestAnimationFrame(update);
        }

        /* =================================================================
           AI CONTROL
           ================================================================= */
        let isFist = false;

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const x = (1 - lm[9].x) * width;
                const y = lm[9].y * height;
                
                // 计算速度
                mouse.vx = x - mouse.x;
                mouse.vy = y - mouse.y;
                mouse.x = x;
                mouse.y = y;
                mouse.active = true;

                // 手势判断: 握拳 (Fist) vs 张开 (Open)
                // 简单判断: 指尖是否靠近掌心
                const tips = [8, 12, 16, 20];
                let foldedCount = 0;
                tips.forEach(t => {
                    if (lm[t].y > lm[t-2].y) foldedCount++; // 指尖在指根下方 (对于举手姿势) -> 这里用距离更准
                });
                
                // 使用边界框判断更稳：食指尖与掌心距离
                const dIndex = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                const isHandOpen = dIndex > 0.15; // 阈值

                if (isHandOpen) {
                    if (mode === 'RUN') {
                        // 切换到聚合模式
                        mode = 'FORM';
                        document.getElementById('status-val').innerText = "FORMATION";
                        document.getElementById('status-val').style.color = "#FFD700";
                        
                        // 更新文字
                        const txt = words[currentWordIdx];
                        document.getElementById('bg-text').innerText = txt;
                        wordTargets = generateTextPoints(txt);
                        currentWordIdx = (currentWordIdx + 1) % words.length;
                        
                        AudioSys.playNeigh(); // 马鸣
                    }
                } else {
                    if (mode === 'FORM') {
                        mode = 'RUN';
                        document.getElementById('status-val').innerText = "GALLOPING";
                        document.getElementById('status-val').style.color = "#FF4500";
                        // 炸开
                        for(let i=0; i<P_COUNT; i++) {
                            P.vx[i] = (Math.random()-0.5) * 20;
                            P.vy[i] = (Math.random()-0.5) * 20;
                        }
                    }
                }

            } else {
                mouse.active = false;
            }
        }

        async function startEngine() {
            document.getElementById('intro').style.opacity = 0;
            setTimeout(() => document.getElementById('intro').style.display = 'none', 1000);
            
            AudioSys.init();
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7});
            hands.onResults(onResults);
            
            const camera = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 640, height: 480
            });
            camera.start();
            
            update();
        }
    </script>
</body>
</html>
