<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glowing Light-Green Christmas Tree</title>
    <style>
        /* èƒŒæ™¯ï¼šæ·±è‰²ä½†å¸¦æœ‰æå…‰æ„Ÿçš„å¾„å‘æ¸å˜ï¼Œè¡¬æ‰˜æµ…ç»¿è‰²å‘å…‰ä½“ */
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #0a1f18 0%, #000000 100%);
            font-family: 'Helvetica Neue', sans-serif; 
        }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* æ‘„åƒå¤´ç”»ä¸­ç”» */
        #video-container {
            position: absolute; bottom: 30px; right: 30px; width: 180px; height: 135px; 
            z-index: 2; border-radius: 16px; overflow: hidden; 
            border: 2px solid rgba(100, 255, 180, 0.5); /* æµ…ç»¿è¾¹æ¡† */
            box-shadow: 0 0 20px rgba(100, 255, 180, 0.3);
            transform: scaleX(-1);
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #video-container:hover { opacity: 1; }
        #video-input { width: 100%; height: 100%; object-fit: cover; }

        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud-text { 
            position: absolute; color: #ccffdd; /* ææµ…çš„ç»¿è‰²æ–‡å­— */
            text-transform: uppercase; letter-spacing: 3px; 
            font-weight: 400; font-size: 12px;
            text-shadow: 0 0 15px rgba(100, 255, 180, 0.8);
            pointer-events: auto; 
        }

        /* æŒ‰é’®ï¼šè§å…‰ç»¿é£æ ¼ */
        .btn {
            background: rgba(0, 40, 20, 0.6);
            border: 1px solid rgba(100, 255, 180, 0.6);
            color: #ccffdd;
            padding: 12px 30px; cursor: pointer; 
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(100, 255, 180, 0.2);
        }
        .btn:hover { 
            background: rgba(100, 255, 180, 0.2); 
            box-shadow: 0 0 30px rgba(100, 255, 180, 0.6);
            color: #fff;
            letter-spacing: 4px;
        }

        #controls { top: 40px; left: 40px; }
        #status-bar { bottom: 40px; left: 40px; font-size: 14px; border-left: 3px solid #66ffaa; padding-left: 15px; }
        
        #instruction { 
            top: 40px; right: 40px; text-align: right; 
            line-height: 2; color: rgba(200, 255, 220, 0.7);
        }
        b { color: #66ffaa; font-weight: 600; text-shadow: 0 0 8px #66ffaa; }

        #loader { 
            position: fixed; top:0; left:0; width:100%; height:100%; background:#000; 
            z-index:99; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            color: #66ffaa; transition: opacity 1.5s ease-out; pointer-events: none;
        }
        .loader-spinner {
            width: 40px; height: 40px; border: 2px solid #111; border-top: 2px solid #66ffaa;
            border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(100, 255, 180, 0.5);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-spinner"></div>
        <div style="letter-spacing: 5px; font-size: 14px;">ACTIVATING GLOW...</div>
    </div>

    <div id="video-container"><video id="video-input"></video></div>

    <div id="ui-layer">
        <div id="controls" class="hud-text">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display:none">
            <button class="btn" onclick="document.getElementById('photo-upload').click()">Upload Memories</button>
        </div>
        <div id="instruction" class="hud-text">
            ğŸ– Open Palm Â· <b>Scatter</b><br>
            âœŠ Fist Â· <b>Tree Form</b><br>
            ğŸ‘Œ Pinch Â· <b>Focus Photo</b><br>
            ğŸ‘‹ Move Â· <b>Rotate View</b>
        </div>
        <div id="status-bar" class="hud-text">SYSTEM: READY</div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ================= ç¾å­¦é…ç½® (é«˜äº®ç‰ˆ) =================
        const CONFIG = {
            colors: {
                // æ ¸å¿ƒä¿®æ”¹ï¼šæµ…ç»¿è‰² + è§å…‰æ„Ÿ
                greenBase: 0x88FFCC,    // æè´¨åº•è‰²ï¼šè–„è·ç»¿
                greenEmissive: 0x00FF66,// è‡ªå‘å…‰è‰²ï¼šå¼ºçƒˆçš„è§å…‰ç»¿
                
                gold: 0xFFED88,         // æ›´æµ…ã€æ›´äº®çš„é‡‘è‰²
                red: 0xFF3355,          // åæ´‹çº¢çš„äº®çº¢è‰²ï¼Œæ›´æ—¶å°š
                
                lightWarm: 0xFFFBE0,    // æäº®æš–å…‰
                lightCool: 0xCCF0FF     // æäº®å†·å…‰
            },
            bloom: {
                strength: 2.8,    // ğŸ’¥ è¾‰å…‰å¼ºåº¦å¤§å¹…å¢åŠ  (åŸ1.5 -> 2.8)
                radius: 0.85,     // å…‰æ™•æ‰©æ•£èŒƒå›´æ›´å¤§
                threshold: 0.1    // ğŸ’¥ é˜ˆå€¼è°ƒä½ï¼Œè®©æ›´å¤šç‰©ä½“äº§ç”Ÿè¾‰å…‰
            }
        };

        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER', ZOOM: 'ZOOM' };
        let appState = STATE.TREE;
        let activePhotoObj = null;

        // ================= åœºæ™¯åŸºç¡€ =================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // é›¾æ°”æ”¹ä¸ºæ·±é’è‰²ï¼Œè¥é€ å‘å…‰æ°›å›´
        scene.fog = new THREE.FogExp2(0x051510, 0.012);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 45);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.3; // ğŸ’¥ å¢åŠ æ›å…‰åº¦ï¼Œè®©ç”»é¢æ›´æ˜äº®
        container.appendChild(renderer.domElement);

        // ================= å¼ºåŠ›ç¯å…‰ç³»ç»Ÿ =================
        // 1. ç¯å¢ƒå…‰ï¼šæå‡äº®åº¦ï¼Œå¸¦ä¸€ç‚¹ç‚¹ç»¿è‰²å€¾å‘
        scene.add(new THREE.AmbientLight(0x406050, 0.8)); // å¼ºåº¦ 0.8

        // 2. ä¸»å…‰æºï¼šè¶…äº®èšå…‰ç¯
        const keyLight = new THREE.SpotLight(CONFIG.colors.lightWarm, 3000); // å¼ºåº¦ 3000
        keyLight.position.set(20, 30, 20);
        keyLight.angle = 0.6;
        keyLight.penumbra = 0.5;
        keyLight.castShadow = true;
        keyLight.shadow.bias = -0.0001;
        scene.add(keyLight);

        // 3. è¡¥å…‰ï¼šå†·è‰²ï¼Œç…§äº®æš—éƒ¨
        const fillLight = new THREE.PointLight(CONFIG.colors.lightCool, 15, 60);
        fillLight.position.set(-20, 5, 10);
        scene.add(fillLight);

        // 4. åº•éƒ¨ä¸Šå°„å…‰ï¼šå¢åŠ ä¸€ç§ç¥åœ£æ„Ÿ/ç§‘æŠ€æ„Ÿ
        const bottomLight = new THREE.PointLight(0x66FF99, 5, 50);
        bottomLight.position.set(0, -15, 0);
        scene.add(bottomLight);

        // ================= åæœŸå¤„ç† (Bloom è¾‰å…‰) =================
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.bloom.strength,
            CONFIG.bloom.radius,
            CONFIG.bloom.threshold
        );
        composer.addPass(bloomPass);

        // ================= æè´¨å·¥å‚ (å‘å…‰ç‰¹åŒ–) =================
        const materials = {
            // æ ¸å¿ƒæè´¨ï¼šå‘å…‰çš„æµ…ç»¿è‰²
            green: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.greenBase,
                emissive: CONFIG.colors.greenEmissive, // ğŸ’¥ å…³é”®ï¼šè‡ªå‘å…‰
                emissiveIntensity: 0.6,                // ğŸ’¥ å‘å…‰å¼ºåº¦
                roughness: 0.2,                        // è¡¨é¢å…‰æ»‘
                metalness: 0.9,                        // é«˜é‡‘å±æ„Ÿï¼Œåå°„ç¯å¢ƒå…‰
            }),
            // é«˜äº®é‡‘
            gold: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                roughness: 0.1, 
                metalness: 1.0, 
                emissive: 0xAA8800,
                emissiveIntensity: 0.4
            }),
            // äº®çº¢
            red: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                roughness: 0.3, 
                metalness: 0.5,
                emissive: 0x550011,
                emissiveIntensity: 0.3
            }),
            // çº¯å…‰çƒ (ç¯ç )
            pureLight: new THREE.MeshBasicMaterial({ color: 0xFFFFFF }) 
        };

        const geometries = {
            sphere: new THREE.SphereGeometry(1, 32, 32), 
            box: new THREE.BoxGeometry(1.2, 1.2, 1.2),
            diamond: new THREE.OctahedronGeometry(0.8, 0),
            plane: new THREE.PlaneGeometry(3, 3) 
        };

        // ================= åœºæ™¯ç”Ÿæˆ =================
        const objects = []; 
        const uploadedTextures = [];

        function createMagicScene() {
            objects.forEach(obj => scene.remove(obj.mesh));
            objects.length = 0;

            const count = 450; // ç¨å¾®å¢åŠ æ•°é‡
            const height = 35;
            const maxR = 14;

            for (let i = 0; i < count; i++) {
                let mesh, type = 'deco';
                const rand = Math.random();

                if (uploadedTextures.length > 0 && rand < 0.15) {
                    type = 'photo';
                    const tex = uploadedTextures[Math.floor(Math.random() * uploadedTextures.length)];
                    const group = new THREE.Group();
                    const imgMesh = new THREE.Mesh(geometries.plane, new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
                    // ç›¸æ¡†æ”¹ä¸ºå‘å…‰ç»¿
                    const frameMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.1, 3.1), materials.green); 
                    frameMesh.position.z = -0.02;
                    group.add(frameMesh);
                    group.add(imgMesh);
                    mesh = group;
                } else if (rand < 0.3) {
                    // çº¯å‘å…‰çš„å°ç¯çƒ (ç™½è‰²æ ¸å¿ƒï¼Œç»¿è‰²å…‰æ™•)
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), materials.pureLight);
                } else if (rand < 0.5) {
                    // é‡‘è‰²ç‚¹ç¼€
                    const geo = Math.random() > 0.5 ? geometries.box : geometries.diamond;
                    mesh = new THREE.Mesh(geo, materials.gold);
                } else if (rand < 0.6) {
                    // çº¢è‰²ç‚¹ç¼€
                    mesh = new THREE.Mesh(geometries.sphere, materials.red);
                } else {
                    // ä¸»ä½“ï¼šæµ…ç»¿å‘å…‰çƒ
                    mesh = new THREE.Mesh(geometries.sphere, materials.green);
                    const s = 0.5 + Math.random() * 0.7;
                    mesh.scale.set(s,s,s);
                }

                if(mesh.type === 'Mesh') {
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                }

                // ä½ç½®ç®—æ³• (è´¹é©¬èºæ—‹)
                const y = (i / count) * height - (height / 2);
                const progress = (y + height/2) / height;
                const r = maxR * (1 - progress) + 0.5;
                const theta = i * 2.39996; 
                const offsetR = r + (Math.random() - 0.5) * 1.5;

                const treePos = new THREE.Vector3(offsetR * Math.cos(theta), y, offsetR * Math.sin(theta));
                const treeRot = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

                // æ•£å¼€ç®—æ³•
                const scatterR = 40 + Math.random() * 20;
                const sTheta = Math.random() * Math.PI * 2;
                const sPhi = Math.acos(2 * Math.random() - 1);
                const scatterPos = new THREE.Vector3(
                    scatterR * Math.sin(sPhi) * Math.cos(sTheta),
                    scatterR * Math.sin(sPhi) * Math.sin(sTheta),
                    scatterR * Math.cos(sPhi)
                );

                mesh.position.copy(treePos);
                mesh.rotation.copy(treeRot);
                scene.add(mesh);

                objects.push({
                    mesh, type, treePos, treeRot, scatterPos,
                    scatterRot: new THREE.Euler(Math.random()*3, Math.random()*3, 0),
                    baseScale: mesh.scale.clone()
                });
            }

            // æ ‘é¡¶ä¹‹æ˜Ÿï¼šæ”¹ä¸ºæå…¶æ˜äº®çš„æ”¾å°„çŠ¶
            const starGeo = new THREE.IcosahedronGeometry(2, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF }); // çº¯ç™½æœ€äº®
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, height/2 + 2, 0);
            
            // æ˜Ÿæ˜Ÿçš„å…‰æ™•ï¼šæµ…ç»¿ + é‡‘è‰²æ··åˆ
            const starLight = new THREE.PointLight(0x88FFCC, 8, 30);
            star.add(starLight);
            scene.add(star);
            
            objects.push({
                mesh: star, type: 'star',
                treePos: new THREE.Vector3(0, height/2 + 2, 0), treeRot: new THREE.Euler(0,0,0),
                scatterPos: new THREE.Vector3(0, 30, 0), scatterRot: new THREE.Euler(0,0,0),
                baseScale: new THREE.Vector3(1,1,1)
            });

            addSparkles();
        }

        // ç²’å­èƒŒæ™¯ï¼šè¤ç«è™«æ•ˆæœ
        function addSparkles() {
            const geometry = new THREE.BufferGeometry();
            const count = 1500;
            const positions = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) positions[i] = (Math.random() - 0.5) * 90;
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x66FF99, // æµ…ç»¿è‰²ç²’å­
                size: 0.4,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const sparkles = new THREE.Points(geometry, material);
            scene.add(sparkles);
            
            sparkles.userData = { 
                update: (t) => {
                    sparkles.rotation.y = t * 0.03;
                    sparkles.position.y = Math.sin(t * 0.3) * 3;
                }
            };
            objects.push({ mesh: sparkles, type: 'sparkle', isStatic: true });
        }

        createMagicScene();
        setTimeout(() => document.getElementById('loader').style.opacity = 0, 1000);

        // ç…§ç‰‡ä¸Šä¼ 
        document.getElementById('photo-upload').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                uploadedTextures.length = 0;
                Array.from(e.target.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image(); img.src = ev.target.result;
                        const tex = new THREE.Texture(img);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        img.onload = () => { tex.needsUpdate = true; createMagicScene(); };
                        uploadedTextures.push(tex);
                    };
                    reader.readAsDataURL(file);
                });
            }
        });

        // ================= çŠ¶æ€è½¬æ¢ =================
        function switchState(newState, data = {}) {
            if (appState === newState && newState !== STATE.ZOOM) return;
            appState = newState;
            
            const statusText = document.getElementById('status-bar');
            statusText.innerText = `MODE: ${newState}`;
            statusText.style.color = '#66ffaa';
            statusText.style.textShadow = '0 0 10px #66ffaa';

            if (newState === STATE.TREE) {
                gsap.to(scene.rotation, { x: 0, y: 0, duration: 2, ease: "power3.inOut" });
            }

            objects.forEach(obj => {
                if(obj.isStatic) return;
                let tPos, tRot, tScale;

                if (newState === STATE.TREE) {
                    tPos = obj.treePos; tRot = obj.treeRot; tScale = obj.baseScale;
                } else if (newState === STATE.SCATTER) {
                    tPos = obj.scatterPos; tRot = obj.scatterRot; tScale = obj.baseScale;
                } else if (newState === STATE.ZOOM) {
                    if (obj === data.targetObj || (obj.mesh && obj.mesh.children && obj.mesh.children.includes(data.targetObj))) {
                        tPos = new THREE.Vector3(0, 5, 30);
                        tRot = new THREE.Euler(0,0,0);
                        tScale = new THREE.Vector3(5, 5, 5);
                    } else {
                        tPos = obj.scatterPos.clone().multiplyScalar(1.5);
                        tRot = obj.scatterRot;
                        tScale = obj.baseScale.clone().multiplyScalar(0.01);
                    }
                }

                gsap.to(obj.mesh.position, {
                    x: tPos.x, y: tPos.y, z: tPos.z,
                    duration: 1.5 + Math.random() * 0.8,
                    ease: "elastic.out(1, 0.6)"
                });
                gsap.to(obj.mesh.rotation, {
                    x: tRot.x, y: tRot.y, z: tRot.z,
                    duration: 1.8, ease: "power2.out"
                });
                if (tScale) {
                    gsap.to(obj.mesh.scale, {
                        x: tScale.x, y: tScale.y, z: tScale.z,
                        duration: 1.2, ease: "back.out(1.5)"
                    });
                }
            });
        }

        // ================= MediaPipe Hands =================
        const videoElement = document.getElementById('video-input');
        
        function onResults(results) {
            if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
            
            const lm = results.multiHandLandmarks[0];
            const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);

            const tips = [8,12,16,20];
            const extended = tips.filter(t => dist(t, 0) > 0.35).length + (dist(4, 0) > 0.3 ? 1 : 0);

            if (extended <= 1) {
                switchState(STATE.TREE);
                activePhotoObj = null;
            } else if (extended >= 4) {
                if (appState === STATE.TREE) switchState(STATE.SCATTER);
                
                if (appState === STATE.SCATTER) {
                    const sensitivity = 2.0;
                    gsap.to(scene.rotation, { 
                        x: (lm[9].y - 0.5) * sensitivity, 
                        y: (lm[9].x - 0.5) * sensitivity * 2, 
                        duration: 0.5 
                    });
                }
            }

            const pinch = dist(4, 8);
            if (pinch < 0.05 && appState === STATE.SCATTER) {
                if (!activePhotoObj) {
                    // æŸ¥æ‰¾æ˜¯ Group ç±»å‹çš„ç…§ç‰‡å¯¹è±¡
                    const photos = objects.filter(o => o.type === 'photo');
                    if (photos.length) {
                        // æ³¨æ„ï¼šè¿™é‡Œ photos[i].mesh æ˜¯ä¸€ä¸ª Group
                        const randomPhoto = photos[Math.floor(Math.random() * photos.length)];
                        // æˆ‘ä»¬éœ€è¦ä¼ é€’ Group é‡Œé¢çš„å›¾ç‰‡ Mesh ç»™ Zoom é€»è¾‘ï¼Œæˆ–è€…ç›´æ¥ä¼  Group
                        // ä¸ºäº†ç®€åŒ–é€»è¾‘ï¼Œæˆ‘ä»¬åœ¨ switchState é‡Œå¤„ç†äº† Group
                        activePhotoObj = randomPhoto.mesh.children[1]; // å–å›¾ç‰‡Mesh
                        switchState(STATE.ZOOM, { targetObj: activePhotoObj });
                    }
                }
            } else if (pinch > 0.1 && appState === STATE.ZOOM) {
                activePhotoObj = null;
                switchState(STATE.SCATTER);
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const cam = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 320, height: 240 });
        cam.start();

        // ================= æ¸²æŸ“å¾ªç¯ =================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            objects.forEach(o => { if(o.isStatic && o.mesh.userData.update) o.mesh.userData.update(t); });

            if (appState === STATE.TREE) {
                scene.rotation.y = Math.sin(t * 0.15) * 0.15;
            } else if (appState === STATE.SCATTER) {
                objects.forEach((o, i) => {
                    if (!o.isStatic) o.mesh.position.y += Math.sin(t * 2 + i) * 0.01;
                });
            }

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
