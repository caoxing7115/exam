<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Dream - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display:flex; flex-direction:column; justify-content:space-between; padding:20px; box-sizing:border-box; }
        #video-preview { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border: 2px solid #D4AF37; border-radius: 8px; transform: scaleX(-1); opacity: 0.7; }
        #status-bar { color: #D4AF37; text-shadow: 0 0 10px #D4AF37; font-size: 14px; background: rgba(0,0,0,0.5); padding:10px; border-radius:4px; pointer-events: auto; max-width:320px; }
        #upload-btn { pointer-events: auto; cursor: pointer; background: rgba(212,175,55,0.2); border: 1px solid #D4AF37; color:#D4AF37; padding:10px 20px; border-radius:20px; transition:0.3s; text-transform:uppercase; font-weight:bold; margin-top:10px; display:inline-block; text-align:center; }
        #upload-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 20px #D4AF37; }
        #loader { position: fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:100; display:flex; justify-content:center; align-items:center; color:#D4AF37; flex-direction:column; transition:opacity 1s; }
        .spinner { width:50px; height:50px; border:3px solid transparent; border-top-color:#D4AF37; border-radius:50%; animation:spin 1s linear infinite; margin-bottom:20px; }
        @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
        .guide { font-size:12px; color:#aaa; margin-top:5px; }
    </style>

    <!-- 三方库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div>INITIALIZING CHRISTMAS MAGIC...</div>
    <div style="font-size:12px; margin-top:10px; color:#666;">Please allow camera access</div>
</div>

<div id="ui-layer">
    <div id="status-bar">
        <div><strong>CURRENT STATE:</strong> <span id="state-text">TREE (MERGED)</span></div>
        <div class="guide">FIST: Merge | OPEN: Scatter | PINCH: Grab</div>
        <label id="upload-btn">
            Upload Photos
            <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
        </label>
    </div>
</div>

<video id="video-preview" playsinline muted></video>
<div id="canvas-container"></div>

<script>
/* ========== 配置 ========== */
const CONFIG = {
    particleCount: 45000,
    treeHeight: 60,
    treeRadius: 25,
    colors: [0xD4AF37, 0xC41E3A, 0x2E8B57],
    bloom: { strength: 1.8, radius: 0.6, threshold: 0.1 }
};

const STATE = {
    current: 'TREE',
    handDetected: false,
    focusedPhoto: null,
    rotationSpeed: 0,
    targetRotationY: 0
};

let scene, camera, renderer, composer;
let treeSystem, snowSystem;
let photos = [];
let raycaster = new THREE.Raycaster();
let smoothedMouse = new THREE.Vector2(0,0); // 平滑坐标
let rawMouse = new THREE.Vector2(0,0);
let handLandmarks = null;
let cursorSprite = null;

/* ========== 初始化 Three.js ========== */
function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020505, 0.015);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 80);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    container.appendChild(renderer.domElement);

    // 后处理 Bloom
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloom.strength, CONFIG.bloom.radius, CONFIG.bloom.threshold);
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // 灯光
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const pl = new THREE.PointLight(0xD4AF37, 1, 100); pl.position.set(0,30,20); scene.add(pl);

    createTreeParticles();
    createSnow();
    createCursorSprite(); // 精灵游标

    window.addEventListener('resize', onWindowResize);
    setTimeout(() => {
        const loader = document.getElementById('loader');
        loader.style.opacity = '0';
        setTimeout(()=> loader.style.display = 'none', 1000);
    }, 1800);
}

/* ========== 粒子系统 ========== */
function createTreeParticles() {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const originalPos = [];
    const scatteredPos = [];

    const colorObj = new THREE.Color();
    for (let i=0;i<CONFIG.particleCount;i++){
        const y = Math.random()*CONFIG.treeHeight;
        const radiusAtY = (CONFIG.treeHeight - y)/CONFIG.treeHeight * CONFIG.treeRadius;
        const angle = y * 1.5 + Math.random()*Math.PI*2;
        const randomOffset = Math.random()*2;
        const tx = Math.cos(angle)*(radiusAtY+randomOffset);
        const tz = Math.sin(angle)*(radiusAtY+randomOffset);
        const ty = y - CONFIG.treeHeight/2;
        positions.push(tx, ty, tz);
        originalPos.push(tx, ty, tz);

        const range = 100;
        scatteredPos.push((Math.random()-0.5)*range, (Math.random()-0.5)*range, (Math.random()-0.5)*range);

        const rand = Math.random();
        let hex = rand>0.95 ? CONFIG.colors[0] : (rand>0.9 ? CONFIG.colors[1] : CONFIG.colors[2]);
        colorObj.setHex(hex);
        colors.push(colorObj.r, colorObj.g, colorObj.b);
        sizes.push(Math.random()*0.5 + 0.1);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('aScatter', new THREE.Float32BufferAttribute(scatteredPos, 3));
    geometry.setAttribute('aOriginal', new THREE.Float32BufferAttribute(originalPos, 3));

    const material = new THREE.ShaderMaterial({
        uniforms:{
            time:{ value:0 },
            pointTexture:{ value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') },
            mixVal:{ value:0.0 }
        },
        vertexShader: `
            attribute float size;
            attribute vec3 color;
            attribute vec3 aScatter;
            attribute vec3 aOriginal;
            varying vec3 vColor;
            uniform float time;
            uniform float mixVal;
            void main(){
                vColor = color;
                vec3 pos = mix(aOriginal, aScatter, mixVal);
                float pulse = sin(time * 3.0 + pos.y * 0.1) * 0.2 + 1.0;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            void main(){
                vec4 c = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
                if(c.a < 0.5) discard;
                gl_FragColor = c;
            }
        `,
        depthWrite:false,
        blending: THREE.AdditiveBlending,
        transparent:true
    });

    treeSystem = new THREE.Points(geometry, material);
    scene.add(treeSystem);
}

/* ========== 飘雪 ========== */
function createSnow() {
    const geometry = new THREE.BufferGeometry();
    const verts = [];
    for (let i=0;i<2000;i++){
        verts.push(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    const material = new THREE.PointsMaterial({ color:0xffffff, size:0.5, transparent:true, opacity:0.8, blending: THREE.AdditiveBlending });
    snowSystem = new THREE.Points(geometry, material);
    scene.add(snowSystem);
}

/* ========== 照片上传与创建 ========== */
document.getElementById('file-input').addEventListener('change', handleImageUpload);
function handleImageUpload(e){
    const files = e.target.files; if(!files || !files.length) return;
    for (let i=0;i<Math.min(files.length, 20); i++){
        const reader = new FileReader();
        reader.onload = function(ev){ createPolaroid(ev.target.result); };
        reader.readAsDataURL(files[i]);
    }
}

function createPolaroid(imgUrl){
    const loader = new THREE.TextureLoader();
    loader.load(imgUrl, (texture) => {
        const group = new THREE.Group();
        const frameGeo = new THREE.PlaneGeometry(6,7);
        const frameMat = new THREE.MeshBasicMaterial({ color:0xffffff, side:THREE.DoubleSide });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        const photoGeo = new THREE.PlaneGeometry(5,5);
        const photoMat = new THREE.MeshBasicMaterial({ map:texture, side:THREE.DoubleSide });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.05; photo.position.y = 0.5;

        group.add(frame); group.add(photo);

        const y = Math.random()*CONFIG.treeHeight - CONFIG.treeHeight/2;
        const radius = (CONFIG.treeHeight/2 - y)/CONFIG.treeHeight * CONFIG.treeRadius * 1.2;
        const angle = Math.random()*Math.PI*2;

        group.userData = {
            treePos: new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius),
            treeRot: new THREE.Euler(0, -angle, 0),
            scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
            scatterRot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
            id: Math.random().toString(36).substr(2,9)
        };

        group.position.copy(group.userData.treePos);
        group.rotation.copy(group.userData.treeRot);
        group.lookAt(0, y, 0);

        scene.add(group);
        photos.push(group);
        gsap.from(group.scale, { x:0, y:0, z:0, duration:1, ease:"elastic.out(1,0.3)" });
    });
}

/* ========== 精灵游标 ========== */
function createCursorSprite(){
    // Canvas 生成圆点纹理
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,size,size);
    // 绘制小实心圆，中心微亮
    const grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    grd.addColorStop(0, 'rgba(212,175,55,1)');
    grd.addColorStop(0.6, 'rgba(212,175,55,0.6)');
    grd.addColorStop(1, 'rgba(212,175,55,0)');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(size/2, size/2, size/4, 0, Math.PI*2); ctx.fill();

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthTest:false, depthWrite:false });
    cursorSprite = new THREE.Sprite(mat);
    cursorSprite.scale.set(1.2,1.2,1.2); // 默认较小
    scene.add(cursorSprite);
}

/* ========== MediaPipe Hand Setup ========== */
function setupMediaPipe(){
    const video = document.getElementById('video-preview');
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.6 });
    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 640, height: 480
    });
    cameraUtils.start();
}

/* ========== 手势识别逻辑（优化版） ========== */
function onHandsResults(results){
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handLandmarks = results.multiHandLandmarks[0];
        STATE.handDetected = true;

        const gesture = detectGesture(handLandmarks);
        updateStateByGesture(gesture);
        updateHandCursor(handLandmarks);

        if (STATE.current === 'SCATTER' && gesture !== 'PINCH') {
            handleRotation(handLandmarks);
        } else if (gesture === 'PINCH') {
            // 仅在散开态尝试抓取
            if (STATE.current === 'SCATTER') tryGrabPhoto(handLandmarks);
        }
    } else {
        STATE.handDetected = false;
        handLandmarks = null;
        STATE.targetRotationY += 0.002;
    }
}

/* 距离辅助 */
function distance(p1, p2){
    return Math.sqrt(Math.pow(p1.x-p2.x,2) + Math.pow(p1.y-p2.y,2) + Math.pow((p1.z||0)-(p2.z||0),2));
}

/* 更稳健的手势判断：
   - 使用相对（归一化）捏合：食指与拇指距离 / 手掌尺度（食指到手腕距离）
*/
function detectGesture(landmarks){
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    const wrist = landmarks[0];
    const middleTip = landmarks[12];
    const ringTip = landmarks[16];
    const pinkyTip = landmarks[20];

    // 手尺度：用中指顶点与腕部距离作为基准（避免绝对阈值）
    const handScale = Math.max(distance(middleTip, wrist), distance(indexTip, wrist), 0.0001);

    const pinchDist = distance(thumbTip, indexTip);
    const pinchNorm = pinchDist / handScale; // 归一化

    // 开合判定：四指与腕部距离平均
    const fingers = [indexTip, middleTip, ringTip, pinkyTip];
    const avgFingerDist = fingers.reduce((s,t)=> s + distance(t, wrist), 0) / fingers.length;
    const fingersOpen = (avgFingerDist / handScale) > 0.9; // 调整阈值

    // 握拳判定
    const isFist = fingers.every(t => (distance(t, wrist) / handScale) < 0.6);

    // 阈值：pinchNorm 较小表示靠拢。微平滑：使用历史值（若需要可扩展）
    if (pinchNorm < 0.35) return 'PINCH';   // 可根据场景微调 0.25~0.4
    if (isFist) return 'FIST';
    if (fingersOpen) return 'OPEN';
    return 'UNKNOWN';
}

/* ========== 手部映射到三维与光标更新 ========== */
/* 将 MediaPipe 的规范化坐标映射到 NDC（-1..1）并平滑 */
function updateHandCursor(landmarks){
    if (!landmarks) return;

    // MediaPipe 的 x: 0(left)-1(right) 对应屏幕坐标（若 video 被镜像，可能需要 flip）
    // 这里假设 video element 已经镜像显示（transform scaleX(-1)），但 landmarks 的 x 是原始（非镜像）。
    // 为了和可视元素更直观对齐，我们使用不镜像的映射（如果你希望镜像逻辑，改为 * -1）
    const ix = landmarks[8].x; // 0..1
    const iy = landmarks[8].y; // 0..1

    // 转 NDC（注意 y 反向）
    const ndcX = (ix * 2) - 1;
    const ndcY = -((iy * 2) - 1);

    // 平滑插值（缓冲防抖）
    rawMouse.set(ndcX, ndcY);
    smoothedMouse.lerp(rawMouse, 0.25); // 平滑系数可调 0.15~0.4

    // 更新精灵位置：把 NDC 转到世界坐标（取在 camera 视野中间的某个深度）
    const v = new THREE.Vector3(smoothedMouse.x, smoothedMouse.y, 0.5); // z=0.5 in NDC (between near/far)
    v.unproject(camera);

    // 通过方向向量从相机到 v 处放置小偏移位置（更贴近场景）
    const dir = v.sub(camera.position).normalize();
    const distanceFromCamera = 25; // 控制游标与相机距离，视场景可调
    const worldPos = camera.position.clone().add(dir.multiplyScalar(distanceFromCamera));

    if (cursorSprite) {
        // 精灵跳动：用 time 控制 scale & opacity
        const t = performance.now() * 0.005;
        const pulse = 0.8 + Math.abs(Math.sin(t*8)) * 0.6; // 0.8 ~ 1.4
        cursorSprite.position.copy(worldPos);
        cursorSprite.scale.setScalar(0.6 * pulse); // 小尺寸
        cursorSprite.material.opacity = 0.5 + 0.5 * Math.abs(Math.sin(t*10));
    }

    // 更新 raycaster 原始用于 pick
    // raycaster.setFromCamera(smoothedMouse, camera); // 我们在 tryGrabPhoto 中使用更准确的 unproject 射线
}

/* ========== 抓取（改进的射线设置） ========== */
function tryGrabPhoto(landmarks){
    if (!landmarks) return;

    // 生成与 cursor 对应的三维点并建立射线（更精确）
    const ndc = new THREE.Vector3(smoothedMouse.x, smoothedMouse.y, 0.5);
    const worldPoint = ndc.clone().unproject(camera);

    const dir = worldPoint.clone().sub(camera.position).normalize();
    raycaster.set(camera.position, dir);
    raycaster.far = 200;

    // 对所有照片的所有子对象进行检测
    const allMeshes = [];
    photos.forEach(g => g.traverse(node => { if (node.isMesh) allMeshes.push(node); }));

    const intersects = raycaster.intersectObjects(allMeshes, true);
    if (intersects && intersects.length > 0) {
        // 找到第一个命中的 mesh，向上找到其顶层 Group（photos 中的元素）
        let hit = intersects[0].object;
        // 向上遍历父链，直到找到在 photos 数组内的对象
        let parent = hit;
        while (parent && !photos.includes(parent)) {
            parent = parent.parent;
        }
        if (parent && parent !== STATE.focusedPhoto) {
            transitionToFocus(parent);
        }
    }
}

/* ========== 状态 & 动画 ========== */
function updateStateByGesture(gesture){
    const statusText = document.getElementById('state-text');
    if (gesture === 'FIST' && STATE.current !== 'TREE') {
        transitionToTree(); statusText.innerText = "TREE (MERGED)";
    } else if (gesture === 'OPEN' && STATE.current !== 'SCATTER') {
        transitionToScatter(); statusText.innerText = "SCATTER (FLOATING)";
    } else if (gesture === 'PINCH') {
        // PINCH 的具体抓取行为在 onHandsResults 中处理
    }
}

function transitionToTree(){
    STATE.current = 'TREE';
    if (STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, { x:1, y:1, z:1, duration:0.5 });
        STATE.focusedPhoto = null;
    }
    gsap.to(treeSystem.material.uniforms.mixVal, { value: 0.0, duration:2, ease:"power2.inOut" });
    photos.forEach(p => {
        gsap.to(p.position, { x: p.userData.treePos.x, y: p.userData.treePos.y, z: p.userData.treePos.z, duration:1.5, ease:"power2.inOut" });
        gsap.to(p.rotation, { x: p.userData.treeRot.x, y: p.userData.treeRot.y, z: p.userData.treeRot.z, duration:1.5 });
        p.lookAt(0, p.position.y, 0);
    });
    gsap.to(camera.position, { x:0, y:20, z:80, duration:2 });
}

function transitionToScatter(){
    STATE.current = 'SCATTER';
    if (STATE.focusedPhoto) {
        gsap.to(STATE.focusedPhoto.scale, { x:1, y:1, z:1, duration:0.5 });
        STATE.focusedPhoto = null;
    }
    gsap.to(treeSystem.material.uniforms.mixVal, { value:1.0, duration:2, ease:"power2.out" });
    photos.forEach(p => {
        gsap.to(p.position, { x: p.userData.scatterPos.x, y: p.userData.scatterPos.y, z: p.userData.scatterPos.z, duration:2, ease:"power2.out" });
        gsap.to(p.rotation, { x: p.userData.scatterRot.x, y: p.userData.scatterRot.y, z: p.userData.scatterRot.z, duration:2 });
    });
}

function transitionToFocus(photoGroup){
    STATE.current = 'FOCUS';
    STATE.focusedPhoto = photoGroup;
    document.getElementById('state-text').innerText = "FOCUS (MEMORY)";
    const targetPos = new THREE.Vector3(0, 0, -20).applyMatrix4(camera.matrixWorld);
    gsap.to(photoGroup.position, {
        x: targetPos.x, y: targetPos.y, z: targetPos.z, duration:1, ease:"power3.out",
        onUpdate: () => { photoGroup.lookAt(camera.position); }
    });
    gsap.to(photoGroup.scale, { x:3, y:3, z:3, duration:1 });
}

/* ========== 旋转控制 ========== */
function handleRotation(landmarks){
    if (!landmarks) return;
    // 用掌心(landmark 9) x 相对中点控制目标角度
    const x = landmarks[9].x;
    const targetAngle = (x - 0.5) * 4;
    STATE.targetRotationY += (targetAngle - STATE.targetRotationY) * 0.05;
}

/* ========== 渲染循环 ========== */
function animate(){
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;
    if (treeSystem) treeSystem.material.uniforms.time.value = time;

    // 雪下落
    if (snowSystem) {
        const pos = snowSystem.geometry.attributes.position.array;
        for (let i=1; i<pos.length; i+=3) {
            pos[i] -= 0.2;
            if (pos[i] < -50) pos[i] = 100;
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    // 场景旋转
    if (STATE.current !== 'FOCUS') {
        const currentRot = scene.rotation.y;
        scene.rotation.y += (STATE.targetRotationY - currentRot) * 0.05;
        if (!STATE.handDetected && STATE.current === 'TREE') {
            scene.rotation.y += 0.002;
            STATE.targetRotationY = scene.rotation.y;
        }
    }

    // 照片漂浮
    if (STATE.current === 'SCATTER') {
        photos.forEach((p, i) => {
            if (p !== STATE.focusedPhoto) p.position.y += Math.sin(time + i) * 0.02;
        });
    }

    composer.render();
}

/* ========== 窗口调整 ========== */
function onWindowResize(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

/* ========== 启动 ========== */
window.onload = function(){
    initThree();
    setupMediaPipe();
    animate();
};
</script>
</body>
</html>
