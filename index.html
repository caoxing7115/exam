<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Dreamscape | Gesture Interactive</title>
    <style>
        /* CSS Variables & Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital@1&display=swap');

        :root {
            --gold: #d4af37;
            --dark-green: #0a1f12;
            --red: #8a0e0e;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Cinzel', serif;
            user-select: none;
        }

        /* Canvas & UI Layers */
        #canvas-container { position: fixed; inset: 0; z-index: 1; }
        
        #ui-layer {
            position: fixed; inset: 0; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px;
            background: radial-gradient(circle at center, transparent 0%, #000000 120%);
        }

        /* Cinematic Loading Screen */
        #overlay {
            position: fixed; inset: 0; z-index: 20;
            background: radial-gradient(circle, #1a2e22 0%, #000000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-in-out;
            pointer-events: auto;
        }

        h1 {
            color: var(--gold);
            font-size: 3.5rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
            margin-bottom: 10px;
            letter-spacing: 5px;
            text-align: center;
        }

        p { color: #fff; opacity: 0.8; font-family: 'Playfair Display', serif; font-size: 1.2rem; }

        .btn-upload {
            margin-top: 30px;
            padding: 15px 50px;
            font-size: 1.2rem;
            color: var(--gold);
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--gold);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);
            position: relative;
            overflow: hidden;
        }
        .btn-upload:hover {
            background: var(--gold);
            color: #000;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
            transform: scale(1.05);
        }

        /* HUD Elements */
        .hud-top-right {
            position: absolute; top: 30px; right: 30px;
            text-align: right;
        }
        
        #video-preview {
            width: 160px; height: 120px;
            border: 1px solid var(--gold);
            border-radius: 8px;
            opacity: 0.8;
            transform: scaleX(-1); /* Mirror */
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .status-badge {
            display: inline-block;
            margin-top: 10px;
            padding: 5px 15px;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--gold);
            color: var(--gold);
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
            backdrop-filter: blur(5px);
        }

        .controls-hint {
            position: absolute; bottom: 30px; left: 30px;
            color: rgba(255,255,255,0.6);
            font-size: 0.9rem;
            line-height: 1.8;
        }
        .key { color: var(--gold); font-weight: bold; }

        #file-input { display: none; }
        
        /* Loading Spinner */
        .loader {
            width: 40px; height: 40px;
            border: 3px solid rgba(212,175,55,0.3);
            border-radius: 50%;
            border-top-color: var(--gold);
            animation: spin 1s ease-in-out infinite;
            margin-top: 20px;
            display: none;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

    </style>
    
    <!-- Import Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="overlay">
        <h1>Christmas Memories</h1>
        <p>Êå•Âä®ÂèåÊâãÔºåÁÇπ‰∫ÆÊÇ®ÁöÑËÆ∞ÂøÜÁîªÂªä</p>
        <button class="btn-upload" onclick="document.getElementById('file-input').click()">‰∏ä‰º†ÁÖßÁâáÂºÄÂêØÊóÖÁ®ã</button>
        <div class="loader" id="loader"></div>
        <input type="file" id="file-input" multiple accept="image/*" onchange="initApp(this)">
    </div>

    <div id="ui-layer">
        <div class="controls-hint">
            <div><span class="key">‚úä Êè°Êã≥</span> :: ËÅöÂêàÂú£ËØûÊ†ë</div>
            <div><span class="key">üñê Âº†Êâã</span> :: Êº´Â§©ÊòüÊ≤≥ (ÊóãËΩ¨ÊéßÂà∂)</div>
            <div><span class="key">ü§è ÊçèÂêà</span> :: ÊäìÂèñÂõûÂøÜ (ÁÖßÁâáÊîæÂ§ß)</div>
        </div>
        <div class="hud-top-right">
            <video id="video-preview" playsinline></video>
            <br>
            <div class="status-badge" id="status-text">Á≥ªÁªüÂàùÂßãÂåñ‰∏≠...</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- SHADERS -->
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute vec3 customColor;
        attribute float flashOffset;
        
        varying vec3 vColor;
        varying float vAlpha;
        
        uniform float uTime;
        uniform float uPixelRatio;
        uniform float uMixFactor; // 0 = Tree, 1 = Scatter
        
        attribute vec3 targetTree;
        attribute vec3 targetScatter;

        void main() {
            vColor = customColor;
            
            // Mix Positions based on state
            vec3 pos = mix(targetTree, targetScatter, uMixFactor);
            
            // Add subtle noise movement when scattered
            if (uMixFactor > 0.1) {
                pos.x += sin(uTime * 0.5 + pos.y) * 0.5 * uMixFactor;
                pos.y += cos(uTime * 0.3 + pos.x) * 0.5 * uMixFactor;
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // Blinking Effect (Sine wave based on time + random offset)
            float flash = sin(uTime * 3.0 + flashOffset);
            float brightness = 0.6 + 0.4 * flash;
            
            // Size attenuation
            gl_PointSize = size * uPixelRatio * (200.0 / -mvPosition.z) * brightness;
            gl_Position = projectionMatrix * mvPosition;
            
            vAlpha = brightness;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
            // Circle shape logic without texture dependency for pure code
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if (dist > 0.5) discard;
            
            // Soft edge
            float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
            
            // Output
            gl_FragColor = vec4(vColor, alpha * vAlpha);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Config & Constants ---
        const CONSTANTS = {
            PARTICLE_COUNT: 45000,
            ORNAMENT_COUNT: 200,
            TREE_HEIGHT: 50,
            TREE_RADIUS: 18,
            COLORS: [
                new THREE.Color('#d4af37'), // Gold
                new THREE.Color('#8a0e0e'), // Red
                new THREE.Color('#228b22'), // Green
                new THREE.Color('#50c878'), // Emerald
                new THREE.Color('#ffffff')  // Snow/Lights
            ],
            CAMERA_Z_TREE: 70,
            CAMERA_Z_SCATTER: 40
        };

        const STATE = {
            TREE: 0,
            SCATTER: 1,
            DETAIL: 2,
            current: 0
        };

        // --- Global Variables ---
        let scene, camera, renderer, composer;
        let particleSystem, particleUniforms;
        let ornaments = [];
        let photoMeshes = [];
        let cursorMesh;
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedPhoto = null;
        
        // Motion Control
        let targetMix = 0; // 0 for Tree, 1 for Scatter
        let currentMix = 0;
        let sceneRotationTarget = { x: 0, y: 0 };
        let handCursorPos = new THREE.Vector3();

        // MediaPipe
        let gestureMode = 'NONE';
        let isHandPresent = false;
        let lastGestureTime = 0;

        // --- Init & Setup ---

        window.initApp = async (input) => {
            if (input.files.length === 0) return;
            
            document.querySelector('.btn-upload').style.display = 'none';
            document.getElementById('loader').style.display = 'block';

            // 1. Setup Three.js
            initThree();
            
            // 2. Process Photos
            await createPhotoGallery(input.files);
            
            // 3. Start MediaPipe
            await initMediaPipe();

            // 4. Reveal
            gsap.to('#overlay', { opacity: 0, duration: 1.5, onComplete: () => {
                document.getElementById('overlay').style.display = 'none';
            }});
            
            animate();
        };

        function initThree() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020405, 0.015); // Atmospheric Fog

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 5, CONSTANTS.CAMERA_Z_TREE);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setClearColor(0x020405);
            container.appendChild(renderer.domElement);

            // Post Processing (Cinematic Bloom)
            const renderScene = new RenderPass(scene, camera);
            
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; // Only bright things glow
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lighting (for Photos/Meshes)
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            const point = new THREE.PointLight(0xd4af37, 2, 100);
            point.position.set(10, 20, 20);
            const spot = new THREE.SpotLight(0xff0000, 5);
            spot.position.set(-20, 50, 0);
            scene.add(ambient, point, spot);

            // Create Objects
            createAdvancedParticles();
            createDecorations();
            createCursor();
            createSnow();

            window.addEventListener('resize', onResize);
        }

        // --- Core: Particle System (Shader Based) ---
        function createAdvancedParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONSTANTS.PARTICLE_COUNT;

            const targetTree = [];
            const targetScatter = [];
            const colors = [];
            const sizes = [];
            const flashOffsets = [];

            const colorHelper = new THREE.Color();

            for (let i = 0; i < count; i++) {
                // 1. Tree Shape (Cone Spiral with Noise)
                const t = Math.random();
                const angle = t * Math.PI * 2 * 30; // 30 winds
                const radius = (1 - t) * CONSTANTS.TREE_RADIUS;
                
                // Add foliage thickness
                const rOffset = Math.random() * 3; 
                const tx = Math.cos(angle) * (radius + rOffset);
                const ty = (t * CONSTANTS.TREE_HEIGHT) - (CONSTANTS.TREE_HEIGHT / 2);
                const tz = Math.sin(angle) * (radius + rOffset);
                targetTree.push(tx, ty, tz);

                // 2. Scatter Shape (Galaxy Sphere)
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                const rScatter = 60 + Math.random() * 40;
                
                targetScatter.push(
                    rScatter * Math.cos(theta) * Math.sin(phi),
                    rScatter * Math.sin(theta) * Math.sin(phi),
                    rScatter * Math.cos(phi)
                );

                // 3. Attributes
                const color = CONSTANTS.COLORS[Math.floor(Math.random() * CONSTANTS.COLORS.length)];
                colors.push(color.r, color.g, color.b);
                sizes.push(Math.random() * 0.5 + 0.1);
                flashOffsets.push(Math.random() * Math.PI * 2);
            }

            geometry.setAttribute('targetTree', new THREE.Float32BufferAttribute(targetTree, 3));
            geometry.setAttribute('targetScatter', new THREE.Float32BufferAttribute(targetScatter, 3));
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(targetTree, 3)); // Init at tree
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('flashOffset', new THREE.Float32BufferAttribute(flashOffsets, 1));

            particleUniforms = {
                uTime: { value: 0 },
                uPixelRatio: { value: renderer.getPixelRatio() },
                uMixFactor: { value: 0.0 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: particleUniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- Visuals: Snow & Decorations ---
        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1000; i++) {
                pos.push((Math.random()-0.5)*200, Math.random()*100, (Math.random()-0.5)*200);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color: 0xffffff, size: 0.4, transparent:true, opacity:0.6});
            const snow = new THREE.Points(geo, mat);
            snow.userData = { speeds: pos.map(() => Math.random() * 0.2 + 0.1) };
            scene.add(snow);
            scene.userData.snow = snow;
        }

        function createDecorations() {
            // Instanced Mesh for Gifts (Red Cubes)
            const geom = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x8a0e0e, 
                roughness: 0.3, 
                metalness: 0.5 
            });
            const mesh = new THREE.InstancedMesh(geom, mat, CONSTANTS.ORNAMENT_COUNT);
            
            const dummy = new THREE.Object3D();
            const positionsTree = [];
            const positionsScatter = [];

            for(let i=0; i<CONSTANTS.ORNAMENT_COUNT; i++) {
                // Tree Pos
                const t = Math.random();
                const angle = Math.random() * Math.PI * 2;
                const r = (1 - t) * CONSTANTS.TREE_RADIUS * 0.9; // Inside foliage
                const h = (t * CONSTANTS.TREE_HEIGHT) - (CONSTANTS.TREE_HEIGHT/2);
                
                positionsTree.push(new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r));
                
                // Scatter Pos
                positionsScatter.push(new THREE.Vector3(
                    (Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100
                ));

                dummy.position.copy(positionsTree[i]);
                dummy.rotation.set(Math.random(), Math.random(), Math.random());
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            
            mesh.userData = { tree: positionsTree, scatter: positionsScatter };
            scene.add(mesh);
            ornaments.push(mesh);
        }

        function createCursor() {
            const geometry = new THREE.RingGeometry(0.8, 1, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xd4af37, side: THREE.DoubleSide, transparent: true, opacity: 0.8 
            });
            cursorMesh = new THREE.Mesh(geometry, material);
            cursorMesh.visible = false;
            scene.add(cursorMesh);
        }

        async function createPhotoGallery(files) {
            const loader = new THREE.TextureLoader();
            const frameGeo = new THREE.BoxGeometry(4, 5, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: 0xd4af37, metalness: 1, roughness: 0.2 
            }); // Back side

            const maxPhotos = Math.min(files.length, 20); // Limit

            for (let i = 0; i < maxPhotos; i++) {
                const url = URL.createObjectURL(files[i]);
                const tex = await new Promise(r => loader.load(url, r));
                tex.colorSpace = THREE.SRGBColorSpace;
                
                // Crop to square aspect for Polaroid style
                // (Simplification: just scale mesh UVs if needed, or assume object fit)
                
                const photoMat = new THREE.MeshBasicMaterial({ map: tex });
                
                const group = new THREE.Group();
                
                // Frame
                const frame = new THREE.Mesh(frameGeo, frameMat);
                group.add(frame);
                
                // Photo
                const photo = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 3.5), photoMat);
                photo.position.set(0, 0.5, 0.06);
                group.add(photo);
                
                // Back Gold Plate
                const back = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 4.8), goldMat);
                back.position.set(0, 0, -0.06);
                back.rotation.y = Math.PI;
                group.add(back);

                // Position on Tree
                const t = Math.random() * 0.8 + 0.1; // Avoid very top/bottom
                const angle = i * (Math.PI * 2 / maxPhotos) + Math.random();
                const r = ((1 - t) * CONSTANTS.TREE_RADIUS) + 2;
                const h = (t * CONSTANTS.TREE_HEIGHT) - (CONSTANTS.TREE_HEIGHT/2);

                group.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
                group.lookAt(0, h, 0); // Face out
                
                // Store Data
                group.userData = {
                    treePos: group.position.clone(),
                    treeRot: group.quaternion.clone(),
                    scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                    scatterRot: new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random()*3, Math.random()*3, 0)),
                    originalScale: 1
                };

                photoMeshes.push(group);
                scene.add(group);
            }
        }

        // --- Logic: MediaPipe & State Machine ---

        async function initMediaPipe() {
            const video = document.getElementById('video-preview');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(processHandResults);

            const cam = new window.Camera(video, {
                onFrame: async () => await hands.send({image: video}),
                width: 320, height: 240
            });
            cam.start();
        }

        // EMA Smoothing variables
        let smoothHand = { x: 0.5, y: 0.5, z: 0 };
        const alpha = 0.2; // Smoothing factor

        function processHandResults(results) {
            const statusEl = document.getElementById('status-text');
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                isHandPresent = false;
                statusEl.innerText = "Á≠âÂæÖÊâãÂäø...";
                cursorMesh.visible = false;
                return;
            }

            isHandPresent = true;
            cursorMesh.visible = true;
            const lm = results.multiHandLandmarks[0];

            // 1. Smooth Coordinates (Index finger base as center)
            const rawX = lm[9].x;
            const rawY = lm[9].y;
            smoothHand.x += (rawX - smoothHand.x) * alpha;
            smoothHand.y += (rawY - smoothHand.y) * alpha;

            // Map to Screen Coordinates for Raycaster
            mouse.x = (1 - smoothHand.x) * 2 - 1; // Flip X
            mouse.y = -(smoothHand.y * 2 - 1);

            // Update 3D Cursor Position
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = 40; // Arbitrary distance in front of camera
            const cursorPos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // Smooth cursor movement
            cursorMesh.position.lerp(cursorPos, 0.2);
            cursorMesh.lookAt(camera.position);

            // 2. Gesture Recognition
            const now = Date.now();
            if (now - lastGestureTime < 300) return; // Debounce

            const isFist = isFingerDown(lm, 8) && isFingerDown(lm, 12) && isFingerDown(lm, 16) && isFingerDown(lm, 20);
            const isOpen = !isFingerDown(lm, 8) && !isFingerDown(lm, 12) && !isFingerDown(lm, 16) && !isFingerDown(lm, 20);
            const isPinch = getDistance(lm[4], lm[8]) < 0.05;

            // State Logic
            if (isPinch) {
                statusEl.innerText = "ü§è ÊäìÂèñ‰∏≠";
                handlePinch();
            } else if (isFist) {
                statusEl.innerText = "‚úä ËÅöÂêà";
                changeState(STATE.TREE);
            } else if (isOpen) {
                statusEl.innerText = "üñê Êï£ÂºÄÊéßÂà∂";
                changeState(STATE.SCATTER);
                // Control Rotation
                sceneRotationTarget.x = (smoothHand.y - 0.5) * 2; // Up/Down
                sceneRotationTarget.y = (smoothHand.x - 0.5) * 2; // Left/Right
            }
        }

        function isFingerDown(lm, tipIdx) {
            return lm[tipIdx].y > lm[tipIdx - 2].y; // Tip below pip
        }
        
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function changeState(newState) {
            if (STATE.current === newState && newState !== STATE.SCATTER) return;
            
            // If exiting detail view
            if (STATE.current === STATE.DETAIL && newState !== STATE.DETAIL) {
                 if(selectedPhoto) {
                     gsap.to(selectedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
                 }
                 selectedPhoto = null;
                 // Reset camera
                 gsap.to(camera.position, {
                    z: newState === STATE.TREE ? CONSTANTS.CAMERA_Z_TREE : CONSTANTS.CAMERA_Z_SCATTER,
                    x: 0, y: 5,
                    duration: 1.5,
                    ease: "power2.inOut"
                 });
            } else if (newState !== STATE.DETAIL) {
                 gsap.to(camera.position, {
                    z: newState === STATE.TREE ? CONSTANTS.CAMERA_Z_TREE : CONSTANTS.CAMERA_Z_SCATTER,
                    duration: 1.5
                 });
            }

            STATE.current = newState;
            targetMix = (newState === STATE.TREE) ? 0 : 1;
        }

        function handlePinch() {
            if (STATE.current !== STATE.SCATTER && STATE.current !== STATE.DETAIL) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoMeshes, true);

            if (intersects.length > 0) {
                // Find root group
                let obj = intersects[0].object;
                while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                
                if (obj !== selectedPhoto) {
                    // Zoom logic
                    if(selectedPhoto) gsap.to(selectedPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
                    
                    selectedPhoto = obj;
                    STATE.current = STATE.DETAIL;

                    // Move photo to front of camera
                    const offset = new THREE.Vector3(0, 0, -15).applyQuaternion(camera.quaternion);
                    const targetPos = camera.position.clone().add(offset);
                    
                    gsap.to(selectedPhoto.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 1, ease: "power2.out"
                    });
                    
                    gsap.to(selectedPhoto.quaternion, {
                        x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w,
                        duration: 1
                    });
                    
                    gsap.to(selectedPhoto.scale, {x: 2.5, y: 2.5, z: 2.5, duration: 1});
                }
            }
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            
            // 1. Update Uniforms
            if(particleUniforms) {
                particleUniforms.uTime.value = time;
                // Lerp Mix Factor
                currentMix += (targetMix - currentMix) * 0.05;
                particleUniforms.uMixFactor.value = currentMix;
            }

            // 2. Update Ornaments (InstancedMesh)
            ornaments.forEach(mesh => {
                const dummy = new THREE.Object3D();
                const treePos = mesh.userData.tree;
                const scatterPos = mesh.userData.scatter;
                
                for(let i=0; i<CONSTANTS.ORNAMENT_COUNT; i++) {
                    const tp = treePos[i];
                    const sp = scatterPos[i];
                    
                    // Lerp Position
                    dummy.position.x = tp.x * (1-currentMix) + sp.x * currentMix;
                    dummy.position.y = tp.y * (1-currentMix) + sp.y * currentMix;
                    dummy.position.z = tp.z * (1-currentMix) + sp.z * currentMix;
                    
                    // Add some rotation
                    dummy.rotation.set(time*0.5 + i, time*0.3 + i, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
            });

            // 3. Update Photos
            photoMeshes.forEach(mesh => {
                if(mesh === selectedPhoto && STATE.current === STATE.DETAIL) return;

                const tPos = mesh.userData.treePos;
                const tRot = mesh.userData.treeRot;
                const sPos = mesh.userData.scatterPos;
                const sRot = mesh.userData.scatterRot;

                mesh.position.lerpVectors(tPos, sPos, currentMix);
                mesh.quaternion.slerpQuaternions(tRot, sRot, currentMix);
                
                // Floating effect
                if(currentMix > 0.5) {
                    mesh.position.y += Math.sin(time + mesh.id) * 0.02;
                }
            });

            // 4. Update Snow
            if(scene.userData.snow) {
                const snow = scene.userData.snow;
                const positions = snow.geometry.attributes.position.array;
                const speeds = snow.userData.speeds;
                
                for(let i=0; i<1000; i++) {
                    positions[i*3+1] -= speeds[i]; // Y axis down
                    if(positions[i*3+1] < -50) positions[i*3+1] = 50; // Reset
                }
                snow.geometry.attributes.position.needsUpdate = true;
            }

            // 5. Global Rotation
            if (STATE.current === STATE.TREE) {
                scene.rotation.y += 0.001; // Auto rotate
                scene.rotation.x *= 0.95; // Reset tilt
            } else if (STATE.current === STATE.SCATTER) {
                // Hand control rotation
                scene.rotation.y += (sceneRotationTarget.y * 0.5 - scene.rotation.y) * 0.05;
                scene.rotation.x += (sceneRotationTarget.x * 0.5 - scene.rotation.x) * 0.05;
            }

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if(particleUniforms) particleUniforms.uPixelRatio.value = renderer.getPixelRatio();
        }
    </script>
</body>
</html>
