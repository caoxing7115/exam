<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Gesture Christmas Tree</title>
    <style>
        /* èƒŒæ™¯ï¼šæ·±é‚ƒçš„å¾„å‘æ¸å˜ï¼Œè¥é€ ç©ºé—´æ„Ÿ */
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #1a1f1a 0%, #000000 100%);
            font-family: 'Helvetica Neue', sans-serif; 
        }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* æ‘„åƒå¤´ç”»ä¸­ç”»ï¼šç£¨ç ‚ç»ç’ƒè´¨æ„Ÿ */
        #video-container {
            position: absolute; bottom: 30px; right: 30px; width: 180px; height: 135px; 
            z-index: 2; border-radius: 16px; overflow: hidden; 
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transform: scaleX(-1);
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #video-container:hover { opacity: 1; }
        #video-input { width: 100%; height: 100%; object-fit: cover; }

        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud-text { 
            position: absolute; color: #E5C15D; 
            text-transform: uppercase; letter-spacing: 3px; 
            font-weight: 300; font-size: 12px;
            text-shadow: 0 0 15px rgba(229, 193, 93, 0.4);
            pointer-events: auto; 
        }

        /* æŒ‰é’®ï¼šæµå…‰é‡‘æ•ˆæœ */
        .btn {
            background: rgba(10, 20, 15, 0.6);
            border: 1px solid rgba(229, 193, 93, 0.4);
            color: #E5C15D;
            padding: 12px 30px; cursor: pointer; 
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
            border-radius: 4px;
        }
        .btn:hover { 
            background: rgba(229, 193, 93, 0.2); 
            box-shadow: 0 0 20px rgba(229, 193, 93, 0.4);
            letter-spacing: 4px;
        }

        #controls { top: 40px; left: 40px; }
        #status-bar { bottom: 40px; left: 40px; font-size: 14px; border-left: 3px solid #E5C15D; padding-left: 15px; }
        
        #instruction { 
            top: 40px; right: 40px; text-align: right; 
            line-height: 2; color: rgba(255,255,255,0.6);
        }
        b { color: #E5C15D; font-weight: 600; }

        #loader { 
            position: fixed; top:0; left:0; width:100%; height:100%; background:#000; 
            z-index:99; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            color: #E5C15D; transition: opacity 1.5s ease-out; pointer-events: none;
        }
        .loader-spinner {
            width: 40px; height: 40px; border: 2px solid #333; border-top: 2px solid #E5C15D;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-spinner"></div>
        <div style="letter-spacing: 5px; font-size: 14px;">IGNITING LIGHTS...</div>
    </div>

    <div id="video-container"><video id="video-input"></video></div>

    <div id="ui-layer">
        <div id="controls" class="hud-text">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display:none">
            <button class="btn" onclick="document.getElementById('photo-upload').click()">Upload Memories</button>
        </div>
        <div id="instruction" class="hud-text">
            ğŸ– Open Palm Â· <b>Scatter</b><br>
            âœŠ Fist Â· <b>Tree Form</b><br>
            ğŸ‘Œ Pinch Â· <b>Focus Photo</b><br>
            ğŸ‘‹ Move Â· <b>Rotate View</b>
        </div>
        <div id="status-bar" class="hud-text">SYSTEM: INITIALIZING...</div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ================= ç¾å­¦é…ç½® =================
        const CONFIG = {
            colors: {
                green: 0x052B18,      // ææ·±æ£®æ—ç»¿ (Dark Forest Green)
                gold: 0xFFAE00,       // æš–é‡‘è‰² (Warm Gold)
                red: 0x8A0303,        // å¤©é¹…ç»’çº¢ (Velvet Red)
                lightWarm: 0xFFF0DD,  // æš–å…‰
                lightCool: 0xDDEEFF     // å†·å…‰è¡¥å…‰
            },
            bloom: {
                strength: 1,    // è¾‰å…‰å¼ºåº¦
                radius: 0.6,      // æ‰©æ•£åŠå¾„
                threshold: 0.1    // åªæœ‰äº®éƒ¨æ‰å‘å…‰
            }
        };

        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER', ZOOM: 'ZOOM' };
        let appState = STATE.TREE;
        let activePhotoObj = null;

        // ================= åœºæ™¯åŸºç¡€ =================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // é»‘è‰²é›¾æ°”è¥é€ æ·±é‚ƒèƒŒæ™¯ï¼Œéšè—è¿œå¤„ç©¿å¸®
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 45);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶DPIä»¥ä¿è¯æ€§èƒ½
        // å…³é”®ï¼šå¼€å¯ç‰©ç†å…‰ç…§è®¡ç®—å’Œé˜´å½±
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒæ˜ å°„
        renderer.toneMappingExposure = 1.1;
        container.appendChild(renderer.domElement);

        // ================= é«˜çº§ç¯å…‰ç³»ç»Ÿ =================
        // 1. ç¯å¢ƒå…‰ï¼šå¾®å¼±çš„è“è‰²ï¼Œæ¨¡æ‹Ÿæœˆå…‰
        scene.add(new THREE.AmbientLight(0x404060, 0.5));

        // 2. ä¸»å…‰æº (Key Light)ï¼šæš–å…‰ï¼Œä»å³ä¸Šæ–¹ç…§å°„ï¼Œäº§ç”Ÿä¸»è¦é˜´å½±
        const keyLight = new THREE.SpotLight(CONFIG.colors.lightWarm, 2000);
        keyLight.position.set(20, 30, 20);
        keyLight.angle = 0.6;
        keyLight.penumbra = 0.5;
        keyLight.castShadow = true;
        keyLight.shadow.bias = -0.0001;
        keyLight.shadow.mapSize.width = 2048; // é«˜è´¨é‡é˜´å½±
        keyLight.shadow.mapSize.height = 2048;
        scene.add(keyLight);

        // 3. è¡¥å…‰ (Fill Light)ï¼šå†·å…‰ï¼Œä»å·¦ä¾§å¡«å……æš—éƒ¨ï¼Œå¢åŠ è‰²å½©å¯¹æ¯”
        const fillLight = new THREE.PointLight(CONFIG.colors.lightCool, 8, 50);
        fillLight.position.set(-20, 10, 10);
        scene.add(fillLight);

        // 4. è½®å»“å…‰ (Rim Light)ï¼šåœ¨èƒŒåå‹¾å‹’ç‰©ä½“è¾¹ç¼˜ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
        const rimLight = new THREE.SpotLight(CONFIG.colors.gold, 10);
        rimLight.position.set(0, 20, -20);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);

        // ================= åæœŸå¤„ç† (è¾‰å…‰) =================
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.bloom.strength,
            CONFIG.bloom.radius,
            CONFIG.bloom.threshold
        );
        composer.addPass(bloomPass);

        // ================= æè´¨å·¥å‚ =================
        // ä½¿ç”¨ MeshStandardMaterial å®ç° PBR æ•ˆæœ
        const materials = {
            // å“‘å…‰ç»¿ï¼šä½é‡‘å±åº¦ï¼Œé«˜ç²—ç³™åº¦
            green: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, 
                roughness: 0.8, 
                metalness: 0.1,
                flatShading: false 
            }),
            // å¥¢åé‡‘ï¼šé«˜é‡‘å±åº¦ï¼Œä½ç²—ç³™åº¦ (åƒæŠ›å…‰é‡‘å±)
            gold: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                roughness: 0.15, 
                metalness: 1.0, 
                emissive: 0x332200, // è‡ªå‘å…‰å¢åŠ äº®åº¦
                envMapIntensity: 1.0
            }),
            // ä¸ç»’çº¢
            red: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                roughness: 0.6, 
                metalness: 0.4 
            }),
            // å‘å…‰æè´¨ (ç”¨äºç¯çƒ)
            glowing: new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFDD88,
                emissiveIntensity: 2,
                toneMapped: false
            })
        };

        const geometries = {
            sphere: new THREE.SphereGeometry(1, 48, 48), // æ›´åœ†æ»‘
            box: new THREE.BoxGeometry(1.2, 1.2, 1.2),
            // ç²¾è‡´çš„å…«é¢ä½“ä½œä¸ºé’»çŸ³å½¢çŠ¶
            diamond: new THREE.OctahedronGeometry(0.8, 0),
            plane: new THREE.PlaneGeometry(3, 3) 
        };

        // ================= åœºæ™¯ç”Ÿæˆé€»è¾‘ =================
        const objects = []; 
        const uploadedTextures = [];

        function createMagicScene() {
            // æ¸…ç†
            objects.forEach(obj => scene.remove(obj.mesh));
            objects.length = 0;

            const count = 400; // å¢åŠ å¯†åº¦
            const height = 35;
            const maxR = 14;

            for (let i = 0; i < count; i++) {
                let mesh, type = 'deco';
                const rand = Math.random();

                // --- 1. åˆ›å»ºç½‘æ ¼ ---
                if (uploadedTextures.length > 0 && rand < 0.15) {
                    type = 'photo';
                    const tex = uploadedTextures[Math.floor(Math.random() * uploadedTextures.length)];
                    // ç»™ç…§ç‰‡åŠ ä¸ªé‡‘è‰²è¾¹æ¡†
                    const group = new THREE.Group();
                    
                    // ç…§ç‰‡æœ¬ä½“
                    const imgMesh = new THREE.Mesh(geometries.plane, new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
                    
                    // è¾¹æ¡†
                    const frameMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 3.2), materials.gold);
                    frameMesh.position.z = -0.05; // ç¨å¾®é å
                    
                    group.add(frameMesh);
                    group.add(imgMesh);
                    mesh = group; // è®© mesh æŒ‡å‘ç»„
                    
                    // ä¿®æ­£ Group çš„ castShadow é—®é¢˜éœ€è¦éå†å­å…ƒç´ ï¼Œè¿™é‡Œç®€åŒ–
                    imgMesh.castShadow = true; frameMesh.castShadow = true;

                } else if (rand < 0.25) {
                    // å‘å…‰å°ç¯çƒ
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), materials.glowing);
                } else if (rand < 0.45) {
                    // é‡‘è‰²é¥°å“ (é’»çŸ³å½¢æˆ–æ–¹å—)
                    const geo = Math.random() > 0.5 ? geometries.box : geometries.diamond;
                    mesh = new THREE.Mesh(geo, materials.gold);
                } else if (rand < 0.55) {
                    // çº¢è‰²çƒ
                    mesh = new THREE.Mesh(geometries.sphere, materials.red);
                } else {
                    // ç»¿è‰²çƒ (æ ‘çš„ä¸»ä½“)
                    mesh = new THREE.Mesh(geometries.sphere, materials.green);
                    const s = 0.5 + Math.random() * 0.8;
                    mesh.scale.set(s,s,s);
                }

                if(mesh.type === 'Mesh') {
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                }

                // --- 2. ä½ç½®è®¡ç®— (è´¹é©¬èºæ—‹ - æ›´è‡ªç„¶çš„æ¤ç‰©åˆ†å¸ƒ) ---
                const y = (i / count) * height - (height / 2); // -H/2 to H/2
                const progress = (y + height/2) / height; // 0 to 1
                
                // åŠå¾„éšé«˜åº¦æ”¶ç¼©ï¼Œå‘ˆåœ†é”¥çŠ¶
                const r = maxR * (1 - progress) + 0.5;
                
                // é»„é‡‘è§’åº¦ (137.5åº¦)
                const theta = i * 2.39996; 
                
                // ç¨å¾®å¢åŠ ä¸€ç‚¹éšæœºåç§»ï¼Œè®©æ ‘çœ‹èµ·æ¥ä¸é‚£ä¹ˆæ­»æ¿
                const offsetR = r + (Math.random() - 0.5) * 1.5;

                const treePos = new THREE.Vector3(
                    offsetR * Math.cos(theta),
                    y,
                    offsetR * Math.sin(theta)
                );
                
                const treeRot = new THREE.Euler(
                    Math.random() * Math.PI, 
                    Math.random() * Math.PI, 
                    Math.random() * Math.PI
                );

                // --- 3. æ•£å¼€ä½ç½® (æ˜Ÿäº‘çŠ¶) ---
                const scatterR = 40 + Math.random() * 20;
                const sTheta = Math.random() * Math.PI * 2;
                const sPhi = Math.acos(2 * Math.random() - 1);
                const scatterPos = new THREE.Vector3(
                    scatterR * Math.sin(sPhi) * Math.cos(sTheta),
                    scatterR * Math.sin(sPhi) * Math.sin(sTheta),
                    scatterR * Math.cos(sPhi)
                );

                // åˆå§‹åŒ–
                mesh.position.copy(treePos);
                mesh.rotation.copy(treeRot);
                scene.add(mesh);

                objects.push({
                    mesh, type,
                    treePos, treeRot,
                    scatterPos,
                    scatterRot: new THREE.Euler(Math.random()*3, Math.random()*3, 0),
                    baseScale: mesh.scale.clone()
                });
            }

            // æ ‘é¡¶ä¹‹æ˜Ÿ
            const starGeo = new THREE.IcosahedronGeometry(1.8, 0);
            const starMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, emissive: 0xFFD700, emissiveIntensity: 3, toneMapped: false 
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, height/2 + 1.5, 0);
            
            // å¢åŠ æ˜Ÿæ˜Ÿçš„å…‰æ™•
            const starLight = new THREE.PointLight(0xFFD700, 5, 20);
            star.add(starLight);
            
            scene.add(star);
            objects.push({
                mesh: star, type: 'star',
                treePos: new THREE.Vector3(0, height/2 + 1.5, 0), treeRot: new THREE.Euler(0,0,0),
                scatterPos: new THREE.Vector3(0, 25, 0), scatterRot: new THREE.Euler(0,0,0),
                baseScale: new THREE.Vector3(1,1,1)
            });

            // æ·»åŠ  "æ˜Ÿå°˜" (Fairy Dust) - ç‹¬ç«‹çš„ç²’å­ç³»ç»Ÿ
            addSparkles();
        }

        // æ˜Ÿå°˜ç²’å­ç³»ç»Ÿ
        function addSparkles() {
            const geometry = new THREE.BufferGeometry();
            const count = 1000;
            const positions = new Float32Array(count * 3);
            
            for(let i=0; i<count*3; i++) {
                positions[i] = (Math.random() - 0.5) * 80;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xFFD700,
                size: 0.3,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const sparkles = new THREE.Points(geometry, material);
            scene.add(sparkles);
            
            // ç®€å•çš„åŠ¨ç”»é€»è¾‘æŒ‚è½½åˆ°å¯¹è±¡ä¸Š
            sparkles.userData = { 
                update: (t) => {
                    sparkles.rotation.y = t * 0.05;
                    sparkles.position.y = Math.sin(t * 0.2) * 2;
                }
            };
            objects.push({ mesh: sparkles, type: 'sparkle', isStatic: true });
        }

        createMagicScene();
        
        // éšè— loading
        setTimeout(() => {
            document.getElementById('loader').style.opacity = 0;
        }, 1000);

        // ç…§ç‰‡ä¸Šä¼ 
        document.getElementById('photo-upload').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                uploadedTextures.length = 0;
                Array.from(e.target.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image(); img.src = ev.target.result;
                        const tex = new THREE.Texture(img);
                        tex.colorSpace = THREE.SRGBColorSpace; // é¢œè‰²æ ¡æ­£
                        img.onload = () => { tex.needsUpdate = true; createMagicScene(); };
                        uploadedTextures.push(tex);
                    };
                    reader.readAsDataURL(file);
                });
            }
        });

        // ================= çŠ¶æ€è½¬æ¢ (GSAP) =================
        function switchState(newState, data = {}) {
            if (appState === newState && newState !== STATE.ZOOM) return;
            appState = newState;
            
            const statusText = document.getElementById('status-bar');
            statusText.innerText = `SYSTEM: ${newState} MODE ACTIVE`;
            statusText.style.color = newState === STATE.TREE ? '#E5C15D' : '#fff';

            // åœºæ™¯æ—‹è½¬å½’é›¶
            if (newState === STATE.TREE) {
                gsap.to(scene.rotation, { x: 0, y: 0, duration: 2, ease: "power3.inOut" });
            }

            objects.forEach(obj => {
                if(obj.isStatic) return; // è·³è¿‡æ˜Ÿå°˜

                let tPos, tRot, tScale;
                const isTarget = (obj.mesh === data.targetObj) || (obj.mesh.children && obj.mesh.children.includes(data.targetObj));

                if (newState === STATE.TREE) {
                    tPos = obj.treePos; tRot = obj.treeRot; tScale = obj.baseScale;
                } else if (newState === STATE.SCATTER) {
                    tPos = obj.scatterPos; tRot = obj.scatterRot; tScale = obj.baseScale;
                } else if (newState === STATE.ZOOM) {
                    if (obj === data.targetObj) {
                        // æ”¾å¤§ç‰¹å†™
                        const camDist = 30; // è·ç¦»ç›¸æœº
                        tPos = new THREE.Vector3(0, 5, camDist);
                        tRot = new THREE.Euler(0,0,0); // é¢å‘ç›¸æœº
                        tScale = new THREE.Vector3(5, 5, 5);
                    } else {
                        // èƒŒæ™¯é€€æ•£
                        tPos = obj.scatterPos.clone().multiplyScalar(1.5);
                        tRot = obj.scatterRot;
                        tScale = obj.baseScale.clone().multiplyScalar(0.01); // å‡ ä¹æ¶ˆå¤±
                    }
                }

                gsap.to(obj.mesh.position, {
                    x: tPos.x, y: tPos.y, z: tPos.z,
                    duration: 1.5 + Math.random() * 0.8,
                    ease: "elastic.out(1, 0.6)"
                });
                
                gsap.to(obj.mesh.rotation, {
                    x: tRot.x, y: tRot.y, z: tRot.z,
                    duration: 1.8, ease: "power2.out"
                });

                if (tScale) {
                    gsap.to(obj.mesh.scale, {
                        x: tScale.x, y: tScale.y, z: tScale.z,
                        duration: 1.2, ease: "back.out(1.5)"
                    });
                }
            });
        }

        // ================= MediaPipe Hands =================
        const videoElement = document.getElementById('video-input');
        
        function onResults(results) {
            if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
            
            const lm = results.multiHandLandmarks[0];
            const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);

            // æ‰‹æŒ‡ä¼¸å±•æ£€æµ‹
            const tips = [8,12,16,20];
            const extended = tips.filter(t => dist(t, 0) > 0.35).length + (dist(4, 0) > 0.3 ? 1 : 0);

            // çŠ¶æ€æœº
            if (extended <= 1) {
                switchState(STATE.TREE);
                activePhotoObj = null;
            } else if (extended >= 4) {
                if (appState === STATE.TREE) switchState(STATE.SCATTER);
                
                // æ—‹è½¬æ§åˆ¶
                if (appState === STATE.SCATTER) {
                    const sensitivity = 2.0;
                    const rx = (lm[9].y - 0.5) * sensitivity;
                    const ry = (lm[9].x - 0.5) * sensitivity * 2;
                    gsap.to(scene.rotation, { x: rx, y: ry, duration: 0.5 });
                }
            }

            // æŠ“å–é€»è¾‘
            const pinch = dist(4, 8);
            if (pinch < 0.05 && appState === STATE.SCATTER) {
                if (!activePhotoObj) {
                    const photos = objects.filter(o => o.type === 'photo');
                    if (photos.length) {
                        activePhotoObj = photos[Math.floor(Math.random() * photos.length)];
                        switchState(STATE.ZOOM, { targetObj: activePhotoObj });
                    }
                }
            } else if (pinch > 0.1 && appState === STATE.ZOOM) {
                activePhotoObj = null;
                switchState(STATE.SCATTER);
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const cam = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 320, height: 240 });
        cam.start();

        // ================= æ¸²æŸ“å¾ªç¯ =================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // æ›´æ–°æ˜Ÿå°˜
            objects.forEach(o => { if(o.isStatic && o.mesh.userData.update) o.mesh.userData.update(t); });

            // æ ‘æ€å‘¼å¸æ•ˆæœ
            if (appState === STATE.TREE) {
                scene.rotation.y = Math.sin(t * 0.15) * 0.15;
            } else if (appState === STATE.SCATTER) {
                // æ•£å¼€æ€æ¼‚æµ®
                objects.forEach((o, i) => {
                    if (!o.isStatic && o.mesh.type !== 'Group') { // ç®€å•çš„ç‰©ä½“æ¼‚æµ®
                        o.mesh.position.y += Math.sin(t * 2 + i) * 0.01;
                    }
                });
            }

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
