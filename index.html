<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUMINOUS: The Particle Christmas Tree</title>
    <style>
        /* --- æ²‰æµ¸å¼ UI è®¾è®¡ --- */
        body { 
            margin: 0; overflow: hidden; 
            background: #000;
            font-family: 'Montserrat', 'Helvetica Neue', sans-serif; 
        }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* ç£¨ç ‚ç»ç’ƒç”»ä¸­ç”» */
        #video-container {
            position: absolute; bottom: 30px; right: 30px; width: 200px; height: 150px; 
            z-index: 10; border-radius: 12px; overflow: hidden; 
            border: 1px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transform: scaleX(-1); opacity: 0; transition: opacity 1s; pointer-events: none;
        }
        #video-container.active { opacity: 0.8; pointer-events: auto; }
        #video-input { width: 100%; height: 100%; object-fit: cover; }

        /* HUD ç•Œé¢ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        .hud-item { position: absolute; color: #E0C080; text-transform: uppercase; letter-spacing: 2px; pointer-events: auto; text-shadow: 0 0 20px rgba(224, 192, 128, 0.4); }
        
        #header { top: 40px; left: 40px; }
        h1 { margin: 0; font-size: 24px; font-weight: 300; color: #fff; }
        .subtitle { font-size: 10px; color: #666; margin-top: 5px; }

        #controls { top: 100px; left: 40px; display: flex; flex-direction: column; gap: 15px; }
        
        .btn {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            color: #E0C080; padding: 12px 24px; font-size: 11px; cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1); backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 10px; width: fit-content;
        }
        .btn:hover { background: #E0C080; color: #000; box-shadow: 0 0 30px #E0C080; border-color: #E0C080; }

        #guide { bottom: 40px; left: 40px; font-size: 11px; line-height: 1.8; color: rgba(255,255,255,0.5); border-left: 2px solid #E0C080; padding-left: 15px; }
        b { color: #fff; font-weight: 600; }

        #status { top: 40px; right: 40px; font-size: 12px; color: #E0C080; display: flex; align-items: center; gap: 10px; }
        .dot { width: 8px; height: 8px; background: #E0C080; border-radius: 50%; box-shadow: 0 0 10px #E0C080; }

        /* Loading Screen */
        #loader { 
            position: fixed; inset: 0; background: #020202; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s ease-in-out;
        }
        .loader-text { color: #E0C080; font-size: 14px; letter-spacing: 5px; margin-top: 20px; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    </style>

    <!-- ä¾èµ–åº“ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="loader">
        <svg width="50" height="50" viewBox="0 0 50 50">
            <circle cx="25" cy="25" r="20" fill="none" stroke="#E0C080" stroke-width="2" stroke-dasharray="100" stroke-dashoffset="0">
                <animate attributeName="stroke-dashoffset" from="0" to="200" dur="2s" repeatCount="indefinite" />
            </circle>
        </svg>
        <div class="loader-text">GENERATING PARTICLES...</div>
    </div>

    <div id="video-container"><video id="video-input"></video></div>

    <div id="ui-layer">
        <div id="header" class="hud-item">
            <h1>LUMINOUS</h1>
            <div class="subtitle">AI GESTURE CONTROLLED GALLERY</div>
        </div>

        <div id="controls" class="hud-item">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display:none">
            <button class="btn" onclick="document.getElementById('photo-upload').click()">
                <span>+</span> UPLOAD MEMORIES
            </button>
        </div>

        <div id="status" class="hud-item">
            <div class="dot"></div> <span id="status-text">SYSTEM STANDBY</span>
        </div>

        <div id="guide" class="hud-item">
            ğŸ– <b>OPEN</b> : SCATTER PARTICLES<br>
            âœŠ <b>FIST</b> : CONVERGE TREE<br>
            ğŸ‘Œ <b>PINCH</b> : INSPECT PHOTO<br>
            ğŸ‘‹ <b>MOVE</b> : ROTATE VIEW
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            particles: 40000,    // æ ‘èº«ç²’å­æ•° (æè‡´è§†è§‰)
            ornaments: 800,      // è£…é¥°ç‰©æ•°é‡
            snowCount: 2000,     // é›ªèŠ±æ•°é‡
            colors: {
                tree: 0x2E8B57,     // åŸºç¡€ç»¿
                treeGlow: 0x00FF88, // è§å…‰ç»¿
                gold: 0xFFD700,
                red: 0xDC143C,
                silver: 0xE0E0E0
            },
            // é¢„è®¾å ä½å›¾ (Unsplash)
            preloadImages: [
                'https://images.unsplash.com/photo-1543589077-47d81606c1bf?auto=format&fit=crop&w=600&q=80',
                'https://images.unsplash.com/photo-1512389142860-9c449e58a543?auto=format&fit=crop&w=600&q=80',
                'https://images.unsplash.com/photo-1576919228236-a097c32a58be?auto=format&fit=crop&w=600&q=80',
                'https://images.unsplash.com/photo-1482638202372-7e28d2366638?auto=format&fit=crop&w=600&q=80'
            ]
        };

        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER', ZOOM: 'ZOOM' };
        let appState = STATE.TREE;
        let activePhoto = null;

        // --- æ ¸å¿ƒ Three.js åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 200);
        camera.position.set(0, 15, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- éŸ³æ•ˆå¼•æ“ (Web Audio API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function sfx(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            if(type === 'magic') { // æ•£å¼€/èšåˆ
                osc.type = 'sine';
                osc.frequency.setValueAtTime(appState === STATE.SCATTER ? 200 : 800, t);
                osc.frequency.exponentialRampToValueAtTime(appState === STATE.SCATTER ? 800 : 200, t + 1);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1);
                osc.start(t); osc.stop(t + 1);
            } else if (type === 'click') { // æ‹ç…§
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, t);
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
            }
        }

        // --- åæœŸå¤„ç† ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- ç¨‹åºåŒ–çº¹ç†ç”Ÿæˆ (æ— éœ€å¤–éƒ¨å›¾ç‰‡) ---
        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            return tex;
        }
        const sparkTex = createSparkTexture();

        // --- åœºæ™¯å¯¹è±¡å®¹å™¨ ---
        let treeParticles;     // 40k ç²’å­ç³»ç»Ÿ
        let snowParticles;     // é›ªèŠ±ç³»ç»Ÿ
        const photoMeshes = [];// æ‹ç«‹å¾—ç…§ç‰‡
        let decorationInstanced; // å®ä¾‹åŒ–è£…é¥°ç‰©

        // ================== 1. æ„å»ºç²’å­æ ‘ (40,000+ ç²’å­) ==================
        function createParticleTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const basePos = []; // å­˜å‚¨åŸå§‹ä½ç½®ç”¨äºåŠ¨ç”»æ¢å¤

            const height = 40;
            const maxRadius = 16;
            const color1 = new THREE.Color(CONFIG.colors.tree);
            const color2 = new THREE.Color(CONFIG.colors.treeGlow);

            for (let i = 0; i < CONFIG.particles; i++) {
                // è´¹é©¬èºæ—‹åˆ†å¸ƒ
                const y = (i / CONFIG.particles) * height - height/2;
                const progress = (y + height/2) / height;
                const radius = (maxRadius * (1 - progress)) + Math.random(); // åº•éƒ¨å®½é¡¶éƒ¨å°–
                const angle = i * 2.5; // é»„é‡‘è§’è¿‘ä¼¼å€¼

                // å¢åŠ ä¸€äº›éšæœºä½“ç§¯æ„Ÿ
                const x = radius * Math.cos(angle) + (Math.random()-0.5)*1.5;
                const z = radius * Math.sin(angle) + (Math.random()-0.5)*1.5;

                positions.push(x, y, z);
                basePos.push(x, y, z);

                // é¢œè‰²æ¸å˜ï¼šå†…éƒ¨æ·±ç»¿ï¼Œå¤–éƒ¨è§å…‰
                const mixRatio = Math.random();
                const c = color1.clone().lerp(color2, Math.pow(mixRatio, 3));
                colors.push(c.r, c.g, c.b);

                sizes.push(Math.random() * 0.4 + 0.1);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            // å­˜å‚¨åŸå§‹ä½ç½®æ•°æ®ç”¨äº Shader æˆ– CPU åŠ¨ç”»
            geometry.userData = { basePos: basePos };

            const material = new THREE.PointsMaterial({
                size: 0.5,
                map: sparkTex,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            treeParticles = new THREE.Points(geometry, material);
            scene.add(treeParticles);
        }

        // ================== 2. æ„å»ºæ‹ç«‹å¾—ç…§ç‰‡å¢™ (Double Sided) ==================
        const polaroidGeo = new THREE.BoxGeometry(3.2, 3.8, 0.05); // æœ‰åšåº¦
        const photoFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.9 });
        
        function createPhotos(textures) {
            // æ¸…ç†æ—§ç…§ç‰‡
            photoMeshes.forEach(p => scene.remove(p));
            photoMeshes.length = 0;

            textures.forEach((tex, i) => {
                // æ‹ç«‹å¾—ç»„åˆ
                const group = new THREE.Group();
                
                // 1. è¾¹æ¡† (Box)
                const frame = new THREE.Mesh(polaroidGeo, photoFrameMat);
                frame.castShadow = true;
                
                // 2. ç…§ç‰‡å†…å®¹ (Plane) - åŒé¢æ¸²æŸ“
                const imgMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const imgGeo = new THREE.PlaneGeometry(2.8, 2.8);
                const img = new THREE.Mesh(imgGeo, imgMat);
                img.position.set(0, 0.3, 0.03); // ç¨å¾®å‡¸å‡º
                const imgBack = img.clone();
                imgBack.position.set(0, 0.3, -0.03);
                imgBack.rotation.y = Math.PI;

                frame.add(img);
                frame.add(imgBack);
                group.add(frame);

                // åˆå§‹ä½ç½®ï¼šéšæœºåˆ†å¸ƒåœ¨æ ‘ä¸­
                const theta = Math.random() * Math.PI * 2;
                const y = (Math.random() - 0.5) * 30;
                const r = 10 + Math.random() * 5;
                group.position.set(r * Math.cos(theta), y, r * Math.sin(theta));
                group.rotation.set(Math.random()*0.5, Math.random()*3, 0);

                // ä¿å­˜åŠ¨ç”»æ•°æ®
                group.userData = {
                    treePos: group.position.clone(),
                    treeRot: group.rotation.clone(),
                    scatterPos: new THREE.Vector3(
                        (Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80
                    ),
                    scatterRot: new THREE.Euler(Math.random()*3, Math.random()*3, Math.random()*3)
                };

                scene.add(group);
                photoMeshes.push(group);
            });
        }

        // ================== 3. åŠ¨æ€é£˜é›ª ==================
        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<CONFIG.snowCount; i++) {
                pos.push((Math.random()-0.5)*100, Math.random()*60, (Math.random()-0.5)*100);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xFFFFFF, size: 0.3, map: sparkTex, 
                transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending
            });
            snowParticles = new THREE.Points(geo, mat);
            scene.add(snowParticles);
        }

        // ================== åˆå§‹åŒ–é€»è¾‘ ==================
        const texLoader = new THREE.TextureLoader();
        texLoader.setCrossOrigin('anonymous');

        function init() {
            createParticleTree();
            createSnow();

            // åŠ è½½é¢„è®¾å›¾ç‰‡
            const loadedTexs = [];
            let count = 0;
            CONFIG.preloadImages.forEach(url => {
                texLoader.load(url, (t) => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    loadedTexs.push(t);
                    count++;
                    if(count === CONFIG.preloadImages.length) {
                        createPhotos(loadedTexs);
                        document.getElementById('loader').style.opacity = 0;
                        setTimeout(() => document.getElementById('loader').remove(), 1000);
                    }
                });
            });

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0x444444));
            const spot = new THREE.SpotLight(0xffaa00, 800);
            spot.position.set(30, 50, 30);
            spot.angle = 0.5;
            spot.penumbra = 0.5;
            scene.add(spot);
            const rim = new THREE.SpotLight(0x00ffaa, 500); // èµ›åšç»¿è½®å»“å…‰
            rim.position.set(-30, 20, -30);
            scene.add(rim);
        }

        init();

        // ç”¨æˆ·ä¸Šä¼ å¤„ç†
        document.getElementById('photo-upload').addEventListener('change', (e) => {
            if(e.target.files.length) {
                const newTexs = [];
                Array.from(e.target.files).forEach(f => {
                    const url = URL.createObjectURL(f);
                    const img = new Image();
                    img.src = url;
                    img.onload = () => {
                        const t = new THREE.Texture(img);
                        t.colorSpace = THREE.SRGBColorSpace;
                        t.needsUpdate = true;
                        newTexs.push(t);
                        createPhotos(newTexs);
                    };
                });
            }
        });

        // ================== åŠ¨ç”»çŠ¶æ€æœº ==================
        function transition(newState, targetObj = null) {
            if(appState === newState && newState !== STATE.ZOOM) return;
            appState = newState;
            sfx('magic');
            
            document.getElementById('status-text').innerText = `MODE: ${newState}`;
            document.querySelector('.dot').style.background = newState === STATE.TREE ? '#E0C080' : '#00FF88';

            // 1. ç²’å­æ ‘çš„å½¢æ€ (é€šè¿‡ Scale æ¨¡æ‹Ÿæ•£å¼€ï¼Œæ€§èƒ½æœ€ä½³)
            if (newState === STATE.TREE) {
                gsap.to(treeParticles.scale, { x: 1, y: 1, z: 1, duration: 1.5, ease: "back.out(1.7)" });
                gsap.to(treeParticles.rotation, { y: 0, duration: 1.5 });
                gsap.to(bloomPass, { strength: 1.2, radius: 0.5, duration: 2 });
            } else {
                // æ•£å¼€æ—¶ï¼Œæ ‘ç²’å­å˜å¤§å¹¶é€æ˜ï¼Œæ¨¡æ‹Ÿæ¶ˆæ•£
                gsap.to(treeParticles.scale, { x: 3, y: 3, z: 3, duration: 2, ease: "power2.out" });
                gsap.to(bloomPass, { strength: 2.5, radius: 1.0, duration: 2 });
            }

            // 2. ç…§ç‰‡çš„å½¢æ€
            photoMeshes.forEach(mesh => {
                let tPos, tRot;

                if (newState === STATE.TREE) {
                    tPos = mesh.userData.treePos;
                    tRot = mesh.userData.treeRot;
                    gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                } else if (newState === STATE.SCATTER) {
                    tPos = mesh.userData.scatterPos;
                    tRot = mesh.userData.scatterRot;
                    gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                } else if (newState === STATE.ZOOM) {
                    if (mesh === targetObj) {
                        sfx('click');
                        // å¼ºåˆ¶å±…ä¸­ï¼šç§»åŠ¨åˆ°ç›¸æœºæ­£å‰æ–¹
                        // å‡è®¾ç›¸æœºåœ¨ (0, 15, 60)ï¼Œç…§ç‰‡æ”¾åˆ° (0, 15, 50)
                        tPos = new THREE.Vector3(0, 15, 50);
                        tRot = new THREE.Euler(0, 0, 0);
                        gsap.to(mesh.scale, { x: 2, y: 2, z: 2, duration: 1 });
                        
                        // é‡ç½®åœºæ™¯æ—‹è½¬ä»¥ä¾¿å¯¹é½
                        gsap.to(scene.rotation, { x: 0, y: 0, z: 0, duration: 1 });
                    } else {
                        // å…¶ä»–ç…§ç‰‡é£èµ°
                        tPos = mesh.userData.scatterPos.clone().multiplyScalar(2);
                        tRot = mesh.userData.scatterRot;
                        gsap.to(mesh.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
                    }
                }

                gsap.to(mesh.position, { 
                    x: tPos.x, y: tPos.y, z: tPos.z, 
                    duration: 1.5, ease: "power3.inOut" 
                });
                
                // åªæœ‰é Zoom ç›®æ ‡æ‰æ—‹è½¬ï¼ŒZoom ç›®æ ‡å¿…é¡»æ­£å¯¹
                if(newState !== STATE.ZOOM || mesh !== targetObj) {
                    gsap.to(mesh.rotation, {
                        x: tRot.x, y: tRot.y, z: tRot.z,
                        duration: 1.5
                    });
                } else {
                     gsap.to(mesh.rotation, {x:0,y:0,z:0, duration: 1});
                }
            });
        }

        // ================== AI æ‰‹åŠ¿æ§åˆ¶ ==================
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        hands.onResults(results => {
            if (!results.multiHandLandmarks?.length) return;
            const lm = results.multiHandLandmarks[0];
            const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);

            // æ‰‹åŠ¿è¯†åˆ«
            const isOpen = dist(8, 0) > 0.35 && dist(12, 0) > 0.35 && dist(16, 0) > 0.35;
            const isFist = dist(8, 0) < 0.25 && dist(12, 0) < 0.25;
            const isPinch = dist(4, 8) < 0.05;

            // çŠ¶æ€é€»è¾‘
            if (isFist) {
                transition(STATE.TREE);
                activePhoto = null;
            } else if (isOpen) {
                if (appState === STATE.TREE) transition(STATE.SCATTER);
                
                // æ—‹è½¬æ§åˆ¶ (ä»…åœ¨æ•£å¼€æ¨¡å¼)
                if (appState === STATE.SCATTER) {
                    const rx = (lm[9].y - 0.5) * 2; // ä¸Šä¸‹
                    const ry = (lm[9].x - 0.5) * 4; // å·¦å³
                    gsap.to(scene.rotation, { x: rx, y: ry, duration: 0.5 });
                }
            }

            // æŠ“å–ç…§ç‰‡
            if (isPinch && appState === STATE.SCATTER && !activePhoto) {
                if (photoMeshes.length > 0) {
                    activePhoto = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
                    transition(STATE.ZOOM, activePhoto);
                }
            } else if (!isPinch && appState === STATE.ZOOM) {
                activePhoto = null;
                transition(STATE.SCATTER);
            }
        });

        const camUtils = new Camera(document.getElementById('video-input'), {
            onFrame: async () => await hands.send({image: document.getElementById('video-input')}),
            width: 320, height: 240
        });
        camUtils.start().then(() => {
            document.getElementById('video-container').classList.add('active');
        });

        // ================== æ¸²æŸ“å¾ªç¯ ==================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // 1. ç²’å­æ ‘è‡ªè½¬ä¸å‘¼å¸
            if (appState === STATE.TREE) {
                treeParticles.rotation.y = t * 0.1;
                // æ¨¡æ‹Ÿç²’å­é—ªçƒ (shader would be better, but CPU update for attributes is ok for simple wave)
                // è¿™é‡Œä¸ºäº†æ€§èƒ½ï¼Œåªåšæ•´ä½“æ—‹è½¬
            }

            // 2. ç…§ç‰‡æ¼‚æµ®
            if (appState === STATE.SCATTER) {
                photoMeshes.forEach((m, i) => {
                    m.position.y += Math.sin(t + i) * 0.02;
                    m.rotation.z += Math.cos(t * 0.5 + i) * 0.005;
                });
            }

            // 3. é›ªèŠ±é£˜è½
            if (snowParticles) {
                const positions = snowParticles.geometry.attributes.position.array;
                for(let i=1; i<positions.length; i+=3) {
                    positions[i] -= 0.1; // ä¸‹è½
                    if (positions[i] < -30) positions[i] = 30; // å¾ªç¯
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
                snowParticles.rotation.y = t * 0.05;
            }

            composer.render();
        }

        animate();

        // çª—å£é€‚é…
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
