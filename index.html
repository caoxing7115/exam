<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 å¤©é©¬æµæ˜Ÿ Â· äº’åŠ¨ç¥ˆç¦</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Orbitron:wght@900&display=swap" rel="stylesheet">
    
    <!-- MediaPipe AI -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; background: #000; overflow: hidden; user-select: none; font-family: 'Orbitron', sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI ç•Œé¢ */
        #ui {
            position: absolute; width: 100%; height: 100%; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 30px;
        }

        /* å¯åŠ¨å± */
        #splash {
            position: absolute; width: 100%; height: 100%; z-index: 100;
            background: radial-gradient(circle, #2a0a00 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
        }

        h1 {
            font-size: 5rem; color: transparent; margin: 0;
            background: linear-gradient(to top, #ffcc00, #ff4500);
            -webkit-background-clip: text; background-clip: text;
            text-shadow: 0 0 50px rgba(255, 69, 0, 0.8);
            letter-spacing: 10px; animation: pulse 2s infinite;
        }

        .btn {
            margin-top: 40px; padding: 15px 50px; border: 2px solid #ff4500;
            background: rgba(255, 69, 0, 0.1); color: #ffcc00; font-size: 1.5rem;
            cursor: pointer; transition: 0.3s; pointer-events: auto;
            font-family: 'Ma Shan Zheng', cursive;
        }
        .btn:hover { background: #ff4500; color: #fff; box-shadow: 0 0 50px #ff4500; }

        /* ç©æ³•æŒ‡å— */
        .guide {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: rgba(255, 255, 255, 0.6); font-family: sans-serif; font-size: 12px;
            line-height: 1.8;
        }
        .guide b { color: #ffcc00; margin-right: 5px; }

        /* çŠ¶æ€æ˜¾ç¤º */
        #mode-display {
            position: absolute; bottom: 30px; left: 30px;
            font-size: 24px; color: #ff4500; text-shadow: 0 0 10px #f00;
        }

        @keyframes pulse { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        video { display: none; }
    </style>
</head>
<body>

    <div id="splash">
        <div style="color: #ff8800; letter-spacing: 5px; margin-bottom: 10px;">2026 YEAR OF FIRE HORSE</div>
        <h1>å¤©é©¬æµæ˜Ÿ</h1>
        <button class="btn" onclick="ignite()">å¼€å¯ç¥ˆç¦å¹»å¢ƒ</button>
        <p style="color: #666; margin-top: 20px; font-size: 12px;">âœ‹ å¼ å¼€é‡Šæ”¾ Â· âœŠ æ¡æ‹³è“„åŠ› Â· âœŒï¸ å‰ªåˆ€æ‰‹æµæ˜Ÿ</p>
    </div>

    <canvas id="canvas"></canvas>
    <video id="input_video" playsinline></video>

    <div id="ui">
        <div class="guide">
            <div>âœŠ æ¡æ‹³ <b>è“„åŠ›æ¼©æ¶¡</b></div>
            <div>âœ‹ å¼ å¼€ <b>é‡‘å­—ç¥ˆç¦</b></div>
            <div>âœŒï¸ å‰ªåˆ€ <b>æµæ˜Ÿå¥½è¿</b></div>
            <div>ğŸ‘† å•æŒ‡ <b>çƒˆç„°ç»˜å›¾</b></div>
        </div>
        <div id="mode-display">WAITING FOR HAND...</div>
    </div>

    <script>
        /* =================================================================
           MODULE 1: PROCEDURAL AUDIO (ç”Ÿæˆå¼éŸ³æ•ˆ)
           ================================================================= */
        const AudioSys = {
            ctx: null,
            master: null,
            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.4;
                this.master.connect(this.ctx.destination);
                this.setupDrone();
            },
            
            // èƒŒæ™¯ä½é¢‘éŸ³å¢™ (Drone)
            setupDrone() {
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = 50;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 120;
                this.droneFilter = filter;
                
                osc.connect(filter);
                filter.connect(this.master);
                osc.start();
            },

            // è°ƒåˆ¶éŸ³æ•ˆ (æ ¹æ®æ‰‹åŠ¿)
            modulate(intensity, type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                
                if (type === 'CHARGE') { // è“„åŠ›ï¼šæå‡é¢‘ç‡å’ŒéŸ³é‡
                    this.droneFilter.frequency.setTargetAtTime(120 + intensity * 500, t, 0.1);
                } else {
                    this.droneFilter.frequency.setTargetAtTime(120, t, 0.5);
                }
            },

            // è§¦å‘éŸ³æ•ˆ (One-shot)
            trigger(type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if (type === 'EXPLOSION') { // ç¥ç¦ç‚¸å¼€
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(0.01, t + 1.5);
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
                    // æ··å“æ¨¡æ‹Ÿ
                    this.playChime();
                } else if (type === 'SPARKLE') { // æµæ˜Ÿ
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800 + Math.random()*400, t);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                }

                osc.connect(gain);
                gain.connect(this.master);
                osc.start();
                osc.stop(t + 2);
            },

            playChime() { // ç¥ç¦æ—¶çš„é’Ÿå£°
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523.25, this.ctx.currentTime); // C5
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
                osc.connect(gain);
                gain.connect(this.master);
                osc.start();
                osc.stop(this.ctx.currentTime + 3);
            }
        };

        /* =================================================================
           MODULE 2: PARTICLE PHYSICS ENGINE (ç²’å­ç‰©ç†)
           ================================================================= */
        const Physics = {
            canvas: document.getElementById('canvas'),
            ctx: document.getElementById('canvas').getContext('2d', {alpha: false}),
            width: 0, height: 0,
            
            // ç²’å­æ±  (1ä¸‡ç²’å­)
            count: 10000,
            // Data Structure: [x, y, vx, vy, life, hue, baseTx, baseTy]
            data: null,
            
            // çŠ¶æ€
            targetText: [], // å½“å‰æ–‡å­—ç›®æ ‡ç‚¹
            textList: ["2026", "é¾™é©¬ç²¾ç¥", "ä¸€é©¬å½“å…ˆ", "é©¬åˆ°æˆåŠŸ", "ä¸‡äº‹å¦‚æ„"],
            textIdx: 0,
            
            mode: 'FLOW', // FLOW, CHARGE, FORM, METEOR
            shake: 0,     // å±å¹•éœ‡åŠ¨å€¼

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.data = new Float32Array(this.count * 8);
                for(let i=0; i<this.count; i++) this.resetP(i);
            },

            resize() {
                this.width = this.canvas.width = window.innerWidth;
                this.height = this.canvas.height = window.innerHeight;
            },

            resetP(i) {
                const idx = i * 8;
                this.data[idx] = Math.random() * this.width;
                this.data[idx+1] = Math.random() * this.height;
                this.data[idx+2] = (Math.random()-0.5)*2;
                this.data[idx+3] = (Math.random()-0.5)*2;
                this.data[idx+4] = Math.random(); // life
                this.data[idx+5] = Math.random() < 0.8 ? 10 + Math.random()*30 : 50; // Hue: Fire(10-40) or Gold(50)
            },

            // é¢„ç”Ÿæˆæ–‡å­—ç‚¹é˜µ
            generateTextTargets(text) {
                const tmp = document.createElement('canvas');
                tmp.width = this.width; tmp.height = this.height;
                const tctx = tmp.getContext('2d');
                tctx.fillStyle = '#000'; tctx.fillRect(0,0,this.width,this.height);
                tctx.fillStyle = '#fff';
                const fSize = Math.min(this.width/text.length, 300);
                tctx.font = `bold ${fSize}px "Ma Shan Zheng"`;
                tctx.textAlign = 'center'; tctx.textBaseline = 'middle';
                tctx.fillText(text, this.width/2, this.height/2);
                
                const pixels = tctx.getImageData(0,0,this.width,this.height).data;
                const points = [];
                // é‡‡æ ·å¯†åº¦
                const step = 5;
                for(let y=0; y<this.height; y+=step) {
                    for(let x=0; x<this.width; x+=step) {
                        if (pixels[(y*this.width+x)*4] > 128) points.push({x,y});
                    }
                }
                return points;
            },

            // æ ¸å¿ƒæ¸²æŸ“å¾ªç¯
            update(mouse) {
                // 1. å±å¹•éœ‡åŠ¨ä¸æ¸…é™¤
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)'; // æ‹–å°¾
                
                let shakeX = 0, shakeY = 0;
                if (this.shake > 0) {
                    shakeX = (Math.random()-0.5) * this.shake;
                    shakeY = (Math.random()-0.5) * this.shake;
                    this.shake *= 0.9; // è¡°å‡
                }
                
                this.ctx.save();
                this.ctx.translate(shakeX, shakeY);
                this.ctx.fillRect(-shakeX, -shakeY, this.width, this.height);

                // 2. ç²’å­æ¸²æŸ“æ¨¡å¼
                this.ctx.globalCompositeOperation = 'lighter'; // é«˜äº®å åŠ 

                const t = Date.now() * 0.001;
                const centerX = this.width/2;
                const centerY = this.height/2;
                const handX = mouse.active ? mouse.x : centerX;
                const handY = mouse.active ? mouse.y : centerY;

                // æ¨¡å¼é€»è¾‘
                const isCharge = this.mode === 'CHARGE';
                const isForm = this.mode === 'FORM';
                const isMeteor = this.mode === 'METEOR';

                // éŸ³æ•ˆæŒç»­è°ƒåˆ¶
                if(isCharge) {
                    this.shake = Math.min(this.shake + 0.5, 10); // éœ‡åŠ¨å¢å¼º
                    AudioSys.modulate(this.shake/10, 'CHARGE');
                } else {
                    AudioSys.modulate(0, 'IDLE');
                }

                // ç²’å­å¾ªç¯
                for(let i=0; i<this.count; i++) {
                    const idx = i * 8;
                    let x = this.data[idx];
                    let y = this.data[idx+1];
                    let vx = this.data[idx+2];
                    let vy = this.data[idx+3];
                    let hue = this.data[idx+5];

                    if (isForm && this.targetText.length > 0) {
                        // === ç¥ç¦èšåˆ (Blessing) ===
                        const pt = this.targetText[i % this.targetText.length];
                        const dx = pt.x - x;
                        const dy = pt.y - y;
                        vx += dx * 0.05; // å¼ºåŠ›å¼¹ç°§
                        vy += dy * 0.05;
                        vx *= 0.8; // é˜»å°¼
                        vy *= 0.8;
                        hue = 50; // é‡‘è‰²

                    } else if (isCharge) {
                        // === è“„åŠ›æ¼©æ¶¡ (Vortex) ===
                        const dx = handX - x;
                        const dy = handY - y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx);
                        
                        // èºæ—‹å¸å…¥
                        vx += Math.cos(angle) * 2;
                        vy += Math.sin(angle) * 2;
                        vx += -Math.sin(angle) * 5; // åˆ‡å‘åŠ›
                        vy += Math.cos(angle) * 5;
                        
                        vx *= 0.9; vy *= 0.9;
                        hue = dist < 100 ? 0 : 30; // è¶Šè¿‘è¶Šçº¢

                    } else if (isMeteor) {
                        // === å¤©é©¬æµæ˜Ÿ (Meteor) ===
                        vx = 15 + Math.random() * 5; // é«˜é€Ÿå‘å³
                        vy = 5 + Math.random() * 5;  // å‘ä¸‹
                        if (x > this.width) { x = 0; y = Math.random() * this.height * 0.5; }
                        hue = 60; // äº®é»„
                        if(Math.random()>0.99) AudioSys.trigger('SPARKLE');

                    } else {
                        // === è‡ªç”±æµåŠ¨ (Flow) ===
                        // æŸæ—å™ªå£°æ¨¡æ‹Ÿç«ç„°
                        const nAngle = (Math.cos(x*0.005 + t) + Math.sin(y*0.005 + t)) * Math.PI;
                        vx += Math.cos(nAngle) * 0.2;
                        vy += Math.sin(nAngle) * 0.2 - 0.1; // ä¸Šå‡çƒ­åŠ›
                        
                        // æ‰‹åŠ¿å¸å¼•
                        if(mouse.active) {
                            const dx = handX - x;
                            const dy = handY - y;
                            const dSq = dx*dx + dy*dy;
                            if(dSq < 40000) {
                                vx += dx * 0.001;
                                vy += dy * 0.001;
                            }
                        }
                        
                        vx *= 0.95; vy *= 0.95;
                        
                        // é¢œè‰²æ ¹æ®é€Ÿåº¦
                        const speed = Math.abs(vx)+Math.abs(vy);
                        hue = 10 + speed * 5; // é€Ÿåº¦è¶Šå¿«è¶Šé»„
                    }

                    x += vx;
                    y += vy;

                    // è¾¹ç•Œ (éæ–‡å­—æ¨¡å¼ä¸‹)
                    if (!isForm) {
                        if(x<0) x=this.width; if(x>this.width) x=0;
                        if(y<0) y=this.height; if(y>this.height) y=0;
                    }

                    this.data[idx] = x; this.data[idx+1] = y;
                    this.data[idx+2] = vx; this.data[idx+3] = vy;
                    this.data[idx+5] = hue;

                    // ç»˜åˆ¶
                    const speed = Math.abs(vx)+Math.abs(vy);
                    this.ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${isForm ? 0.8 : speed/10})`;
                    this.ctx.fillRect(x, y, 2, 2);
                }
                
                this.ctx.restore();
            },

            // åˆ‡æ¢çŠ¶æ€
            setState(newState) {
                if (this.mode === newState) return;
                
                if (newState === 'FORM') {
                    // å‡†å¤‡æ–‡å­—
                    const txt = this.textList[this.textIdx];
                    this.targetText = this.generateTextTargets(txt);
                    this.textIdx = (this.textIdx + 1) % this.textList.length;
                    AudioSys.trigger('EXPLOSION');
                    this.shake = 20; // çˆ†å‘éœ‡åŠ¨
                }
                
                if (newState === 'METEOR') {
                    // é‡ç½®ä½ç½®åˆ°å·¦ä¾§
                    for(let i=0; i<this.count; i++) {
                        this.data[i*8] = Math.random() * this.width * 0.2;
                        this.data[i*8+1] = Math.random() * this.height * 0.5;
                    }
                }

                this.mode = newState;
                
                // æ›´æ–° UI
                const map = {
                    'FLOW': 'ğŸ”¥ çƒˆç„°ç»˜å›¾ (FLUID FIRE)',
                    'CHARGE': 'âš ï¸ èƒ½é‡è“„ç§¯ (CHARGING)',
                    'FORM': 'ğŸ§§ é¾™é©¬ç²¾ç¥ (BLESSING)',
                    'METEOR': 'ğŸŒ  å¤©é©¬æµæ˜Ÿ (LUCKY RAIN)'
                };
                document.getElementById('mode-display').innerText = map[newState];
                document.getElementById('mode-display').style.color = newState === 'CHARGE' ? '#fff' : '#ff4500';
            }
        };

        /* =================================================================
           MODULE 3: GESTURE AI (æ‰‹åŠ¿è¯†åˆ«)
           ================================================================= */
        const Input = {
            video: document.getElementById('input_video'),
            mouse: { x: 0, y: 0, active: false },
            
            async init() {
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7});
                hands.onResults(this.onResults.bind(this));
                
                const camera = new Camera(this.video, {
                    onFrame: async () => { await hands.send({image: this.video}); },
                    width: 640, height: 480
                });
                camera.start();
            },

            onResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const w = Physics.width;
                    const h = Physics.height;
                    
                    // åæ ‡
                    const x = (1 - lm[9].x) * w;
                    const y = lm[9].y * h;
                    this.mouse.x = x; this.mouse.y = y; this.mouse.active = true;

                    // === æ‰‹åŠ¿é€»è¾‘æ ¸å¿ƒ ===
                    
                    // 1. æ¡æ‹³ (Fist): æŒ‡å°–(8,12,16,20) æ¥è¿‘ æŒæ ¹(0)
                    const dTip = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    const isFist = dTip < 0.12;

                    // 2. å‰ªåˆ€æ‰‹ (Victory): é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
                    const isIndexUp = lm[8].y < lm[6].y;
                    const isMiddleUp = lm[12].y < lm[10].y;
                    const isRingDown = lm[16].y > lm[14].y;
                    const isPinkyDown = lm[20].y > lm[18].y;
                    const isVictory = isIndexUp && isMiddleUp && isRingDown && isPinkyDown;

                    // 3. å¼ å¼€ (Open): æ‰€æœ‰æŒ‡å°–è¿œç¦»æŒæ ¹
                    const isOpen = dTip > 0.25; // ç®€åŒ–åˆ¤æ–­

                    // çŠ¶æ€æœºåˆ‡æ¢
                    if (isFist) {
                        Physics.setState('CHARGE');
                    } else if (isVictory) {
                        Physics.setState('METEOR');
                    } else if (isOpen) {
                        // åªæœ‰ä» Charge çŠ¶æ€æ¾å¼€ï¼Œæˆ–è€…æµæ˜ŸçŠ¶æ€ç»“æŸæ‰è¿›å…¥ Form
                        if (Physics.mode === 'CHARGE' || Physics.mode === 'FLOW') {
                             Physics.setState('FORM');
                        }
                        // å¦‚æœå·²ç»åœ¨ FORMï¼Œä¿æŒ FORMï¼Œä¸åˆ‡å› FLOW
                    } else {
                        // å•æŒ‡æˆ–è‡ªç„¶çŠ¶æ€ -> ç»˜å›¾
                        if (Physics.mode !== 'METEOR') Physics.setState('FLOW');
                    }

                } else {
                    this.mouse.active = false;
                    // Physics.setState('FLOW'); // æ— æ‰‹æ—¶è‡ªç”±æµåŠ¨
                }
            }
        };

        /* =================================================================
           BOOTSTRAP
           ================================================================= */
        function loop() {
            Physics.update(Input.mouse);
            requestAnimationFrame(loop);
        }

        function ignite() {
            document.getElementById('splash').style.opacity = 0;
            setTimeout(()=> document.getElementById('splash').style.display = 'none', 800);
            
            AudioSys.init();
            Physics.init();
            Input.init();
            loop();
        }

    </script>
</body>
</html>
